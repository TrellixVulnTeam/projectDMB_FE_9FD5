/**
 * @fileoverview added by tsickle
 * Generated from: lib/transloco.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Inject, Injectable, Optional } from '@angular/core';
import { BehaviorSubject, combineLatest, EMPTY, forkJoin, from, of, Subject } from 'rxjs';
import { catchError, map, retry, shareReplay, switchMap, tap } from 'rxjs/operators';
import { DefaultLoader, TRANSLOCO_LOADER } from './transloco.loader';
import { TRANSLOCO_TRANSPILER } from './transloco.transpiler';
import { flatten, isEmpty, isNil, isScopeObject, isString, size, toCamelCase, unflatten } from './helpers';
import { defaultConfig, TRANSLOCO_CONFIG } from './transloco.config';
import { TRANSLOCO_MISSING_HANDLER } from './transloco-missing-handler';
import { TRANSLOCO_INTERCEPTOR } from './transloco.interceptor';
import { TRANSLOCO_FALLBACK_STRATEGY } from './transloco-fallback-strategy';
import { mergeConfig } from './merge-config';
import { getEventPayload, getLangFromScope, getScopeFromLang, resolveInlineLoader } from './shared';
import { getFallbacksLoaders } from './get-fallbacks-loaders';
import { resolveLoader } from './resolve-loader';
import * as i0 from "@angular/core";
import * as i1 from "./transloco.loader";
import * as i2 from "./transloco.transpiler";
import * as i3 from "./transloco-missing-handler";
import * as i4 from "./transloco.interceptor";
import * as i5 from "./transloco.config";
import * as i6 from "./transloco-fallback-strategy";
/** @type {?} */
let service;
/**
 * @template T
 * @param {?} key
 * @param {?=} params
 * @param {?=} lang
 * @return {?}
 */
export function translate(key, params = {}, lang) {
    return service.translate(key, params, lang);
}
export class TranslocoService {
    /**
     * @param {?} loader
     * @param {?} parser
     * @param {?} missingHandler
     * @param {?} interceptor
     * @param {?} userConfig
     * @param {?} fallbackStrategy
     */
    constructor(loader, parser, missingHandler, interceptor, userConfig, fallbackStrategy) {
        this.loader = loader;
        this.parser = parser;
        this.missingHandler = missingHandler;
        this.interceptor = interceptor;
        this.userConfig = userConfig;
        this.fallbackStrategy = fallbackStrategy;
        this.subscription = null;
        this.translations = new Map();
        this.cache = new Map();
        this.firstFallbackLang = null;
        this.availableLangs = [];
        this.isResolvedMissingOnce = false;
        this.events = new Subject();
        this.events$ = this.events.asObservable();
        this.failedLangs = new Set();
        if (!this.loader) {
            this.loader = new DefaultLoader(this.translations);
        }
        service = this;
        this.mergedConfig = mergeConfig(defaultConfig, userConfig);
        this.setAvailableLangs(this.mergedConfig.availableLangs);
        this.setFallbackLangForMissingTranslation(this.mergedConfig);
        this.setDefaultLang(this.mergedConfig.defaultLang);
        this.lang = new BehaviorSubject(this.getDefaultLang());
        // Don't use distinctUntilChanged as we need the ability to update
        // the value when using setTranslation or setTranslationKeys
        this.langChanges$ = this.lang.asObservable();
        /**
         * When we have a failure, we want to define the next language that succeeded as the active
         */
        this.subscription = this.events$.subscribe((/**
         * @param {?} e
         * @return {?}
         */
        e => {
            if (e.type === 'translationLoadSuccess' && e.wasFailure) {
                // Handle scoped lang
                /** @type {?} */
                const lang = getLangFromScope(e.payload.lang);
                this.setActiveLang(lang);
            }
        }));
    }
    /**
     * @return {?}
     */
    get config() {
        return this.mergedConfig;
    }
    /**
     * @return {?}
     */
    getDefaultLang() {
        return this.defaultLang;
    }
    /**
     * @param {?} lang
     * @return {?}
     */
    setDefaultLang(lang) {
        this.defaultLang = lang;
    }
    /**
     * @return {?}
     */
    getActiveLang() {
        return this.lang.getValue();
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} lang
     * @return {THIS}
     */
    setActiveLang(lang) {
        (/** @type {?} */ (this)).parser.onLangChanged && (/** @type {?} */ (this)).parser.onLangChanged(lang);
        (/** @type {?} */ (this)).lang.next(lang);
        return (/** @type {?} */ (this));
    }
    /**
     * @param {?} langs
     * @return {?}
     */
    setAvailableLangs(langs) {
        this.availableLangs = langs;
    }
    /**
     * Gets the available languages.
     *
     * @return {?}
     * An array of the available languages. Can be either a `string[]` or a `{ id: string; label: string }[]`
     * depending on how the available languages are set in your module.
     */
    getAvailableLangs() {
        return this.availableLangs;
    }
    /**
     * @param {?} path
     * @param {?=} options
     * @return {?}
     */
    load(path, options = {}) {
        if (this.cache.has(path) === false) {
            /** @type {?} */
            let loadTranslation;
            /** @type {?} */
            const isScope = this._isLangScoped(path);
            /** @type {?} */
            const scope = isScope ? getScopeFromLang(path) : null;
            if (this.useFallbackTranslation(path)) {
                // if the path is scope the fallback should be `scope/fallbackLang`;
                /** @type {?} */
                const fallback = isScope ? `${scope}/${this.firstFallbackLang}` : this.firstFallbackLang;
                /** @type {?} */
                const loaders = getFallbacksLoaders(path, fallback, this.loader, options.inlineLoader, { scope });
                loadTranslation = forkJoin(loaders);
            }
            else {
                /** @type {?} */
                const loader = resolveLoader(path, this.loader, options.inlineLoader, { scope });
                loadTranslation = from(loader);
            }
            /** @type {?} */
            const load$ = loadTranslation.pipe(retry(this.config.failedRetries), tap((/**
             * @param {?} translation
             * @return {?}
             */
            translation => {
                if (Array.isArray(translation)) {
                    translation.forEach((/**
                     * @param {?} t
                     * @return {?}
                     */
                    t => {
                        this.handleSuccess(t.lang, t.translation);
                        // Save the fallback in cache so we'll not create a redundant request
                        if (t.lang !== path) {
                            this.cache.set(t.lang, of({}));
                        }
                    }));
                    return;
                }
                this.handleSuccess(path, translation);
            })), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => {
                if (!this.mergedConfig.prodMode) {
                    console.error(`Error while trying to load "${path}"`, error);
                }
                return this.handleFailure(path, options);
            })), shareReplay(1));
            this.cache.set(path, load$);
        }
        return this.cache.get(path);
    }
    /**
     * Gets the instant translated value of a key
     *
     * \@example
     *
     * translate<string>('hello')
     * translate('hello', { value: 'value' })
     * translate<string[]>(['hello', 'key'])
     * translate('hello', { }, 'en')
     * translate('scope.someKey', { }, 'en')
     * @template T
     * @param {?} key
     * @param {?=} params
     * @param {?=} lang
     * @return {?}
     */
    translate(key, params = {}, lang = this.getActiveLang()) {
        if (!key)
            return (/** @type {?} */ (key));
        const { scope, resolveLang } = this.resolveLangAndScope(lang);
        if (Array.isArray(key)) {
            return (/** @type {?} */ (key.map((/**
             * @param {?} k
             * @return {?}
             */
            k => this.translate(scope ? `${scope}.${k}` : k, params, resolveLang)))));
        }
        key = scope ? `${scope}.${key}` : key;
        /** @type {?} */
        const translation = this.getTranslation(resolveLang);
        /** @type {?} */
        const value = translation[key];
        if (!value) {
            return this._handleMissingKey(key, value, params);
        }
        return this.parser.transpile(value, params, translation);
    }
    /**
     * Gets the translated value of a key as observable
     *
     * \@example
     *
     * selectTranslate<string>('hello').subscribe(value => ...)
     * selectTranslate<string>('hello', {}, 'es').subscribe(value => ...)
     * selectTranslate<string>('hello', {}, 'todos').subscribe(value => ...)
     * selectTranslate<string>('hello', {}, { scope: 'todos' }).subscribe(value => ...)
     *
     * @template T
     * @param {?} key
     * @param {?=} params
     * @param {?=} lang
     * @param {?=} _isObject
     * @return {?}
     */
    selectTranslate(key, params, lang, _isObject = false) {
        /** @type {?} */
        let inlineLoader = null;
        /** @type {?} */
        const load = (/**
         * @param {?} lang
         * @param {?=} options
         * @return {?}
         */
        (lang, options) => this.load(lang, options).pipe(map((/**
         * @return {?}
         */
        () => (_isObject ? this.translateObject(key, params, lang) : this.translate(key, params, lang))))));
        if (isNil(lang)) {
            return this.langChanges$.pipe(switchMap((/**
             * @param {?} lang
             * @return {?}
             */
            lang => load(lang))));
        }
        if (isScopeObject(lang)) {
            // it's a scope object.
            /** @type {?} */
            const providerScope = (/** @type {?} */ (lang));
            lang = providerScope.scope;
            inlineLoader = resolveInlineLoader(providerScope, providerScope.scope);
        }
        lang = (/** @type {?} */ (lang));
        if (this.isLang(lang) || this.isScopeWithLang(lang)) {
            return load(lang);
        }
        // it's a scope
        /** @type {?} */
        const scope = lang;
        return this.langChanges$.pipe(switchMap((/**
         * @param {?} lang
         * @return {?}
         */
        lang => load(`${scope}/${lang}`, { inlineLoader }))));
    }
    /**
     * Whether the scope with lang
     *
     * \@example
     *
     * todos/en => true
     * todos => false
     * @private
     * @param {?} lang
     * @return {?}
     */
    isScopeWithLang(lang) {
        return this.isLang(getLangFromScope(lang));
    }
    /**
     * @template T
     * @param {?} key
     * @param {?=} params
     * @param {?=} lang
     * @return {?}
     */
    translateObject(key, params, lang = this.getActiveLang()) {
        if (isString(key) || Array.isArray(key)) {
            if (Array.isArray(key)) {
                return (/** @type {?} */ (key.map((/**
                 * @param {?} k
                 * @return {?}
                 */
                k => this.translateObject(scope ? `${scope}.${k}` : k, params, resolveLang)))));
            }
            const { resolveLang, scope } = this.resolveLangAndScope(lang);
            /** @type {?} */
            const translation = this.getTranslation(resolveLang);
            key = scope ? `${scope}.${key}` : key;
            /** @type {?} */
            const value = unflatten(this.getObjectByKey(translation, key));
            /* If an empty object was returned we want to try and translate the key as a string and not an object */
            return isEmpty(value) ? this.translate(key, params, lang) : this.parser.transpile(value, params, translation);
        }
        /** @type {?} */
        const translations = [];
        for (const [_key, _params] of this.getEntries(key)) {
            translations.push(this.translateObject(_key, _params, lang));
        }
        return translations;
    }
    /**
     * @template T
     * @param {?} key
     * @param {?=} params
     * @param {?=} lang
     * @return {?}
     */
    selectTranslateObject(key, params, lang) {
        if (isString(key) || Array.isArray(key)) {
            return this.selectTranslate(key, params, lang, true);
        }
        const [[firstKey, firstParams], ...rest] = this.getEntries(key);
        /* In order to avoid subscribing multiple times to the load language event by calling selectTranslateObject for each pair,
         * we listen to when the first key has been translated (the language is loaded) and translate the rest synchronously */
        return this.selectTranslateObject(firstKey, firstParams, lang).pipe(map((/**
         * @param {?} value
         * @return {?}
         */
        value => {
            /** @type {?} */
            const translations = [value];
            for (const [_key, _params] of rest) {
                translations.push(this.translateObject(_key, _params, lang));
            }
            return translations;
        })));
    }
    /**
     * @param {?=} langOrScope
     * @return {?}
     */
    getTranslation(langOrScope) {
        if (langOrScope) {
            if (this.isLang(langOrScope)) {
                return this.translations.get(langOrScope) || {};
            }
            else {
                // This is a scope, build the scope value from the translation object
                const { scope, resolveLang } = this.resolveLangAndScope(langOrScope);
                /** @type {?} */
                const translation = this.translations.get(resolveLang) || {};
                return this.getObjectByKey(translation, scope);
            }
        }
        return this.translations;
    }
    /**
     * Gets an object of translations for a given language
     *
     * \@example
     *
     * selectTranslation().subscribe() - will return the current lang translation
     * selectTranslation('es').subscribe()
     * selectTranslation('admin-page').subscribe() - will return the current lang scope translation
     * selectTranslation('admin-page/es').subscribe()
     * @param {?=} lang
     * @return {?}
     */
    selectTranslation(lang) {
        /** @type {?} */
        let language$ = this.langChanges$;
        if (lang) {
            /** @type {?} */
            const scopeLangSpecified = getLangFromScope(lang) !== lang;
            if (this.isLang(lang) || scopeLangSpecified) {
                language$ = of(lang);
            }
            else {
                language$ = this.langChanges$.pipe(map((/**
                 * @param {?} currentLang
                 * @return {?}
                 */
                currentLang => `${lang}/${currentLang}`)));
            }
        }
        return language$.pipe(switchMap((/**
         * @param {?} language
         * @return {?}
         */
        language => this.load(language).pipe(map((/**
         * @return {?}
         */
        () => this.getTranslation(language)))))));
    }
    /**
     * Sets or merge a given translation object to current lang
     *
     * \@example
     *
     * setTranslation({ ... })
     * setTranslation({ ... }, 'en')
     * setTranslation({ ... }, 'es', { merge: false } )
     * setTranslation({ ... }, 'todos/en', { merge: false } )
     * @param {?} translation
     * @param {?=} lang
     * @param {?=} options
     * @return {?}
     */
    setTranslation(translation, lang = this.getActiveLang(), options = {}) {
        /** @type {?} */
        const defaults = { merge: true, emitChange: true };
        /** @type {?} */
        const mergedOptions = Object.assign({}, defaults, options);
        /** @type {?} */
        const scope = getScopeFromLang(lang);
        /**
         * If this isn't a scope we use the whole translation as is
         * otherwise we need to flat the scope and use it
         * @type {?}
         */
        let flattenScopeOrTranslation = translation;
        // Merged the scoped language into the active language
        if (scope) {
            /** @type {?} */
            const key = this.getMappedScope(scope);
            flattenScopeOrTranslation = flatten({ [key]: translation });
        }
        /** @type {?} */
        const currentLang = scope ? getLangFromScope(lang) : lang;
        /** @type {?} */
        const mergedTranslation = Object.assign({}, (mergedOptions.merge && this.getTranslation(currentLang)), flattenScopeOrTranslation);
        /** @type {?} */
        const flattenTranslation = this.mergedConfig.flatten.aot ? mergedTranslation : flatten(mergedTranslation);
        /** @type {?} */
        const withHook = this.interceptor.preSaveTranslation(flattenTranslation, currentLang);
        this.translations.set(currentLang, withHook);
        mergedOptions.emitChange && this.setActiveLang(this.getActiveLang());
    }
    /**
     * Sets translation key with given value
     *
     * \@example
     *
     * setTranslationKey('key', 'value')
     * setTranslationKey('key.nested', 'value')
     * setTranslationKey('key.nested', 'value', 'en')
     * setTranslationKey('key.nested', 'value', 'en', { emitChange: false } )
     * @param {?} key
     * @param {?} value
     * @param {?=} lang
     * @param {?=} options
     * @return {?}
     */
    setTranslationKey(key, value, lang = this.getActiveLang(), 
    // Todo: Use Omit and merge options and lang to one object in v3
    options = {}) {
        /** @type {?} */
        const withHook = this.interceptor.preSaveTranslationKey(key, value, lang);
        /** @type {?} */
        const newValue = {
            [key]: withHook
        };
        this.setTranslation(newValue, lang, Object.assign({}, options, { merge: true }));
    }
    /**
     * Sets the fallback lang for the currently active language
     * @param {?} __0
     * @return {?}
     */
    setFallbackLangForMissingTranslation({ fallbackLang }) {
        /** @type {?} */
        const lang = Array.isArray(fallbackLang) ? fallbackLang[0] : fallbackLang;
        if (this.useFallbackTranslation(lang) && fallbackLang) {
            this.firstFallbackLang = lang;
        }
    }
    /**
     * \@internal
     * @param {?} key
     * @param {?} value
     * @param {?=} params
     * @return {?}
     */
    _handleMissingKey(key, value, params) {
        if (this.config.missingHandler.allowEmpty && value === '') {
            return '';
        }
        if (this.useFallbackTranslation() && !this.isResolvedMissingOnce) {
            // We need to set it to true to prevent a loop
            this.isResolvedMissingOnce = true;
            /** @type {?} */
            const fallbackValue = this.translate(key, params, this.firstFallbackLang);
            this.isResolvedMissingOnce = false;
            return fallbackValue;
        }
        return this.missingHandler.handle(key, this.getMissingHandlerData(), params);
    }
    /**
     * \@internal
     * @param {?} lang
     * @return {?}
     */
    _isLangScoped(lang) {
        return this.getAvailableLangsIds().indexOf(lang) === -1;
    }
    /**
     * Checks if a given string is one of the specified available languages.
     * @param {?} lang
     * @return {?}
     * True if the given string is an available language.
     * False if the given string is not an available language.
     */
    isLang(lang) {
        return this.getAvailableLangsIds().indexOf(lang) !== -1;
    }
    /**
     * \@internal
     *
     * We always want to make sure the global lang is loaded
     * before loading the scope since you can access both via the pipe/directive.
     * @param {?} path
     * @param {?=} inlineLoader
     * @return {?}
     */
    _loadDependencies(path, inlineLoader) {
        /** @type {?} */
        const mainLang = getLangFromScope(path);
        if (this._isLangScoped(path) && !this.isLoadedTranslation(mainLang)) {
            return combineLatest(this.load(mainLang), this.load(path, { inlineLoader }));
        }
        return this.load(path, { inlineLoader });
    }
    /**
     * \@internal
     * @param {?} langOrScope
     * @return {?}
     */
    _completeScopeWithLang(langOrScope) {
        if (this._isLangScoped(langOrScope) && !this.isLang(getLangFromScope(langOrScope))) {
            return `${langOrScope}/${this.getActiveLang()}`;
        }
        return langOrScope;
    }
    /**
     * \@internal
     * @param {?} scope
     * @param {?} alias
     * @return {?}
     */
    _setScopeAlias(scope, alias) {
        if (!this.mergedConfig.scopeMapping) {
            this.mergedConfig.scopeMapping = {};
        }
        this.mergedConfig.scopeMapping[scope] = alias;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
            // Caretaker note: it's important to clean up references to subscriptions since they save the `next`
            // callback within its `destination` property, preventing classes from being GC'd.
            this.subscription = null;
        }
        // Caretaker note: since this is the root provider, it'll be destroyed when the `NgModuleRef.destroy()` is run.
        // Cached values capture `this`, thus leading to a circular reference and preventing the `TranslocoService` from
        // being GC'd. This would lead to a memory leak when server-side rendering is used since the service is created
        // and destroyed per each HTTP request, but any service is not getting GC'd.
        this.cache.clear();
    }
    /**
     * @private
     * @param {?} lang
     * @return {?}
     */
    isLoadedTranslation(lang) {
        return size(this.getTranslation(lang));
    }
    /**
     * @private
     * @return {?}
     */
    getAvailableLangsIds() {
        /** @type {?} */
        const first = this.getAvailableLangs()[0];
        if (isString(first)) {
            return (/** @type {?} */ (this.getAvailableLangs()));
        }
        return ((/** @type {?} */ (this.getAvailableLangs()))).map((/**
         * @param {?} l
         * @return {?}
         */
        l => l.id));
    }
    /**
     * @private
     * @return {?}
     */
    getMissingHandlerData() {
        return Object.assign({}, this.config, { activeLang: this.getActiveLang(), availableLangs: this.availableLangs, defaultLang: this.defaultLang });
    }
    /**
     * Use a fallback translation set for missing keys of the primary language
     * This is unrelated to the fallback language (which changes the active language)
     * @private
     * @param {?=} lang
     * @return {?}
     */
    useFallbackTranslation(lang) {
        return this.config.missingHandler.useFallbackTranslation && lang !== this.firstFallbackLang;
    }
    /**
     * @private
     * @param {?} lang
     * @param {?} translation
     * @return {?}
     */
    handleSuccess(lang, translation) {
        this.setTranslation(translation, lang, { emitChange: false });
        this.events.next({
            wasFailure: !!this.failedLangs.size,
            type: 'translationLoadSuccess',
            payload: getEventPayload(lang)
        });
        this.failedLangs.forEach((/**
         * @param {?} l
         * @return {?}
         */
        l => this.cache.delete(l)));
        this.failedLangs.clear();
    }
    /**
     * @private
     * @param {?} lang
     * @param {?} loadOptions
     * @return {?}
     */
    handleFailure(lang, loadOptions) {
        // When starting to load a first choice language, initialize
        // the failed counter and resolve the fallback langs.
        if (isNil(loadOptions.failedCounter)) {
            loadOptions.failedCounter = 0;
            if (!loadOptions.fallbackLangs) {
                loadOptions.fallbackLangs = this.fallbackStrategy.getNextLangs(lang);
            }
        }
        /** @type {?} */
        const splitted = lang.split('/');
        /** @type {?} */
        const fallbacks = loadOptions.fallbackLangs;
        /** @type {?} */
        const nextLang = fallbacks[loadOptions.failedCounter];
        this.failedLangs.add(lang);
        // This handles the case where a loaded fallback language is requested again
        if (this.cache.has(nextLang)) {
            this.handleSuccess(nextLang, this.getTranslation(nextLang));
            return EMPTY;
        }
        /** @type {?} */
        const isFallbackLang = nextLang === splitted[splitted.length - 1];
        if (!nextLang || isFallbackLang) {
            /** @type {?} */
            let msg = `Unable to load translation and all the fallback languages`;
            if (splitted.length > 1) {
                msg += `, did you misspelled the scope name?`;
            }
            throw new Error(msg);
        }
        /** @type {?} */
        let resolveLang = nextLang;
        // if it's scoped lang
        if (splitted.length > 1) {
            // We need to resolve it to:
            // todos/langNotExists => todos/nextLang
            splitted[splitted.length - 1] = nextLang;
            resolveLang = splitted.join('/');
        }
        loadOptions.failedCounter++;
        this.events.next({
            type: 'translationLoadFailure',
            payload: getEventPayload(lang)
        });
        return this.load(resolveLang, loadOptions);
    }
    /**
     * @private
     * @param {?} scope
     * @return {?}
     */
    getMappedScope(scope) {
        const { scopeMapping = {} } = this.config;
        return scopeMapping[scope] || toCamelCase(scope);
    }
    /**
     * If lang is scope we need to check the following cases:
     * todos/es => in this case we should take `es` as lang
     * todos => in this case we should set the active lang as lang
     * @private
     * @param {?} lang
     * @return {?}
     */
    resolveLangAndScope(lang) {
        /** @type {?} */
        let resolveLang = lang;
        /** @type {?} */
        let scope;
        if (this._isLangScoped(lang)) {
            // en for example
            /** @type {?} */
            const langFromScope = getLangFromScope(lang);
            // en is lang
            /** @type {?} */
            const hasLang = this.isLang(langFromScope);
            // take en
            resolveLang = hasLang ? langFromScope : this.getActiveLang();
            // find the scope
            scope = this.getMappedScope(hasLang ? getScopeFromLang(lang) : lang);
        }
        return { scope, resolveLang };
    }
    /**
     * @private
     * @param {?} translation
     * @param {?} key
     * @return {?}
     */
    getObjectByKey(translation, key) {
        /** @type {?} */
        const result = {};
        /** @type {?} */
        const prefix = `${key}.`;
        for (const currentKey in translation) {
            if (currentKey.startsWith(prefix)) {
                result[currentKey.replace(prefix, '')] = translation[currentKey];
            }
        }
        return result;
    }
    /**
     * @private
     * @param {?} key
     * @return {?}
     */
    getEntries(key) {
        return key instanceof Map ? key.entries() : Object.entries(key);
    }
}
TranslocoService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
TranslocoService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [TRANSLOCO_LOADER,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [TRANSLOCO_TRANSPILER,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [TRANSLOCO_MISSING_HANDLER,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [TRANSLOCO_INTERCEPTOR,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [TRANSLOCO_CONFIG,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [TRANSLOCO_FALLBACK_STRATEGY,] }] }
];
/** @nocollapse */ TranslocoService.ngInjectableDef = i0.defineInjectable({ factory: function TranslocoService_Factory() { return new TranslocoService(i0.inject(i1.TRANSLOCO_LOADER, 8), i0.inject(i2.TRANSLOCO_TRANSPILER), i0.inject(i3.TRANSLOCO_MISSING_HANDLER), i0.inject(i4.TRANSLOCO_INTERCEPTOR), i0.inject(i5.TRANSLOCO_CONFIG), i0.inject(i6.TRANSLOCO_FALLBACK_STRATEGY)); }, token: TranslocoService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.subscription;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.translations;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.cache;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.firstFallbackLang;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.defaultLang;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.mergedConfig;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.availableLangs;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.isResolvedMissingOnce;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.lang;
    /** @type {?} */
    TranslocoService.prototype.langChanges$;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.events;
    /** @type {?} */
    TranslocoService.prototype.events$;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.failedLangs;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.loader;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.parser;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.missingHandler;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.interceptor;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.userConfig;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.fallbackStrategy;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNsb2NvLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AbmduZWF0L3RyYW5zbG9jby8iLCJzb3VyY2VzIjpbImxpYi90cmFuc2xvY28uc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFhLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUN4RSxPQUFPLEVBQUUsZUFBZSxFQUFFLGFBQWEsRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBYyxFQUFFLEVBQUUsT0FBTyxFQUFnQixNQUFNLE1BQU0sQ0FBQztBQUNwSCxPQUFPLEVBQUUsVUFBVSxFQUFFLEdBQUcsRUFBRSxLQUFLLEVBQUUsV0FBVyxFQUFFLFNBQVMsRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNyRixPQUFPLEVBQUUsYUFBYSxFQUFFLGdCQUFnQixFQUFtQixNQUFNLG9CQUFvQixDQUFDO0FBQ3RGLE9BQU8sRUFBRSxvQkFBb0IsRUFBdUIsTUFBTSx3QkFBd0IsQ0FBQztBQWNuRixPQUFPLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsYUFBYSxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUUsV0FBVyxFQUFFLFNBQVMsRUFBRSxNQUFNLFdBQVcsQ0FBQztBQUMzRyxPQUFPLEVBQUUsYUFBYSxFQUFFLGdCQUFnQixFQUFtQixNQUFNLG9CQUFvQixDQUFDO0FBQ3RGLE9BQU8sRUFDTCx5QkFBeUIsRUFHMUIsTUFBTSw2QkFBNkIsQ0FBQztBQUNyQyxPQUFPLEVBQUUscUJBQXFCLEVBQXdCLE1BQU0seUJBQXlCLENBQUM7QUFDdEYsT0FBTyxFQUFFLDJCQUEyQixFQUE2QixNQUFNLCtCQUErQixDQUFDO0FBQ3ZHLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUM3QyxPQUFPLEVBQUUsZUFBZSxFQUFFLGdCQUFnQixFQUFFLGdCQUFnQixF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LEdBQUcsWUFBWSxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNsRSxDQUFDOzs7WUF4bkJGLFVBQVUsU0FBQyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUU7Ozs7NENBbUI3QixRQUFRLFlBQUksTUFBTSxTQUFDLGdCQUFnQjs0Q0FDbkMsTUFBTSxTQUFDLG9CQUFvQjs0Q0FDM0IsTUFBTSxTQUFDLHlCQUF5Qjs0Q0FDaEMsTUFBTSxTQUFDLHFCQUFxQjs0Q0FDNUIsTUFBTSxTQUFDLGdCQUFnQjs0Q0FDdkIsTUFBTSxTQUFDLDJCQUEyQjs7Ozs7Ozs7SUF0QnJDLHdDQUFpRDs7Ozs7SUFDakQsd0NBQXNEOzs7OztJQUN0RCxpQ0FBMkQ7Ozs7O0lBQzNELDZDQUFnRDs7Ozs7SUFDaEQsdUNBQTRCOzs7OztJQUM1Qix3Q0FBc0M7Ozs7O0lBQ3RDLDBDQUE0Qzs7Ozs7SUFDNUMsaURBQXNDOzs7OztJQUN0QyxnQ0FBc0M7O0lBQ3RDLHdDQUFpQzs7Ozs7SUFFakMsa0NBQWdEOztJQUNoRCxtQ0FBcUM7Ozs7O0lBRXJDLHVDQUF3Qzs7Ozs7SUFHdEMsa0NBQXFFOzs7OztJQUNyRSxrQ0FBaUU7Ozs7O0lBQ2pFLDBDQUFrRjs7Ozs7SUFDbEYsdUNBQXdFOzs7OztJQUN4RSxzQ0FBNkQ7Ozs7O0lBQzdELDRDQUF3RiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdCwgSW5qZWN0YWJsZSwgT25EZXN0cm95LCBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0LCBjb21iaW5lTGF0ZXN0LCBFTVBUWSwgZm9ya0pvaW4sIGZyb20sIE9ic2VydmFibGUsIG9mLCBTdWJqZWN0LCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGNhdGNoRXJyb3IsIG1hcCwgcmV0cnksIHNoYXJlUmVwbGF5LCBzd2l0Y2hNYXAsIHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IERlZmF1bHRMb2FkZXIsIFRSQU5TTE9DT19MT0FERVIsIFRyYW5zbG9jb0xvYWRlciB9IGZyb20gJy4vdHJhbnNsb2NvLmxvYWRlcic7XG5pbXBvcnQgeyBUUkFOU0xPQ09fVFJBTlNQSUxFUiwgVHJhbnNsb2NvVHJhbnNwaWxlciB9IGZyb20gJy4vdHJhbnNsb2NvLnRyYW5zcGlsZXInO1xuaW1wb3J0IHtcbiAgQXZhaWxhYmxlTGFuZ3MsXG4gIEhhc2hNYXAsXG4gIElubGluZUxvYWRlcixcbiAgTG9hZE9wdGlvbnMsXG4gIFByb3ZpZGVyU2NvcGUsXG4gIFNldFRyYW5zbGF0aW9uT3B0aW9ucyxcbiAgVHJhbnNsYXRlT2JqZWN0UGFyYW1zLFxuICBUcmFuc2xhdGVQYXJhbXMsXG4gIFRyYW5zbGF0aW9uLFxuICBUcmFuc2xvY29FdmVudHMsXG4gIFRyYW5zbG9jb1Njb3BlXG59IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgZmxhdHRlbiwgaXNFbXB0eSwgaXNOaWwsIGlzU2NvcGVPYmplY3QsIGlzU3RyaW5nLCBzaXplLCB0b0NhbWVsQ2FzZSwgdW5mbGF0dGVuIH0gZnJvbSAnLi9oZWxwZXJzJztcbmltcG9ydCB7IGRlZmF1bHRDb25maWcsIFRSQU5TTE9DT19DT05GSUcsIFRyYW5zbG9jb0NvbmZpZyB9IGZyb20gJy4vdHJhbnNsb2NvLmNvbmZpZyc7XG5pbXBvcnQge1xuICBUUkFOU0xPQ09fTUlTU0lOR19IQU5ETEVSLFxuICBUcmFuc2xvY29NaXNzaW5nSGFuZGxlcixcbiAgVHJhbnNsb2NvTWlzc2luZ0hhbmRsZXJEYXRhXG59IGZyb20gJy4vdHJhbnNsb2NvLW1pc3NpbmctaGFuZGxlcic7XG5pbXBvcnQgeyBUUkFOU0xPQ09fSU5URVJDRVBUT1IsIFRyYW5zbG9jb0ludGVyY2VwdG9yIH0gZnJvbSAnLi90cmFuc2xvY28uaW50ZXJjZXB0b3InO1xuaW1wb3J0IHsgVFJBTlNMT0NPX0ZBTExCQUNLX1NUUkFURUdZLCBUcmFuc2xvY29GYWxsYmFja1N0cmF0ZWd5IH0gZnJvbSAnLi90cmFuc2xvY28tZmFsbGJhY2stc3RyYXRlZ3knO1xuaW1wb3J0IHsgbWVyZ2VDb25maWcgfSBmcm9tICcuL21lcmdlLWNvbmZpZyc7XG5pbXBvcnQgeyBnZXRFdmVudFBheWxvYWQsIGdldExhbmdGcm9tU2NvcGUsIGdldFNjb3BlRnJvbUxhbmcsIHJlc29sdmVJbmxpbmVMb2FkZXIgfSBmcm9tICcuL3NoYXJlZCc7XG5pbXBvcnQgeyBnZXRGYWxsYmFja3NMb2FkZXJzIH0gZnJvbSAnLi9nZXQtZmFsbGJhY2tzLWxvYWRlcnMnO1xuaW1wb3J0IHsgcmVzb2x2ZUxvYWRlciB9IGZyb20gJy4vcmVzb2x2ZS1sb2FkZXInO1xuXG5sZXQgc2VydmljZTogVHJhbnNsb2NvU2VydmljZTtcblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zbGF0ZTxUID0gYW55PihrZXk6IFRyYW5zbGF0ZVBhcmFtcywgcGFyYW1zOiBIYXNoTWFwID0ge30sIGxhbmc/OiBzdHJpbmcpOiBUIHtcbiAgcmV0dXJuIHNlcnZpY2UudHJhbnNsYXRlKGtleSwgcGFyYW1zLCBsYW5nKTtcbn1cblxuQEluamVjdGFibGUoeyBwcm92aWRlZEluOiAncm9vdCcgfSlcbmV4cG9ydCBjbGFzcyBUcmFuc2xvY29TZXJ2aWNlIGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbiB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIHRyYW5zbGF0aW9ucyA9IG5ldyBNYXA8c3RyaW5nLCBUcmFuc2xhdGlvbj4oKTtcbiAgcHJpdmF0ZSBjYWNoZSA9IG5ldyBNYXA8c3RyaW5nLCBPYnNlcnZhYmxlPFRyYW5zbGF0aW9uPj4oKTtcbiAgcHJpdmF0ZSBmaXJzdEZhbGxiYWNrTGFuZzogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgZGVmYXVsdExhbmc6IHN0cmluZztcbiAgcHJpdmF0ZSBtZXJnZWRDb25maWc6IFRyYW5zbG9jb0NvbmZpZztcbiAgcHJpdmF0ZSBhdmFpbGFibGVMYW5nczogQXZhaWxhYmxlTGFuZ3MgPSBbXTtcbiAgcHJpdmF0ZSBpc1Jlc29sdmVkTWlzc2luZ09uY2UgPSBmYWxzZTtcbiAgcHJpdmF0ZSBsYW5nOiBCZWhhdmlvclN1YmplY3Q8c3RyaW5nPjtcbiAgbGFuZ0NoYW5nZXMkOiBPYnNlcnZhYmxlPHN0cmluZz47XG5cbiAgcHJpdmF0ZSBldmVudHMgPSBuZXcgU3ViamVjdDxUcmFuc2xvY29FdmVudHM+KCk7XG4gIGV2ZW50cyQgPSB0aGlzLmV2ZW50cy5hc09ic2VydmFibGUoKTtcblxuICBwcml2YXRlIGZhaWxlZExhbmdzID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgQE9wdGlvbmFsKCkgQEluamVjdChUUkFOU0xPQ09fTE9BREVSKSBwcml2YXRlIGxvYWRlcjogVHJhbnNsb2NvTG9hZGVyLFxuICAgIEBJbmplY3QoVFJBTlNMT0NPX1RSQU5TUElMRVIpIHByaXZhdGUgcGFyc2VyOiBUcmFuc2xvY29UcmFuc3BpbGVyLFxuICAgIEBJbmplY3QoVFJBTlNMT0NPX01JU1NJTkdfSEFORExFUikgcHJpdmF0ZSBtaXNzaW5nSGFuZGxlcjogVHJhbnNsb2NvTWlzc2luZ0hhbmRsZXIsXG4gICAgQEluamVjdChUUkFOU0xPQ09fSU5URVJDRVBUT1IpIHByaXZhdGUgaW50ZXJjZXB0b3I6IFRyYW5zbG9jb0ludGVyY2VwdG9yLFxuICAgIEBJbmplY3QoVFJBTlNMT0NPX0NPTkZJRykgcHJpdmF0ZSB1c2VyQ29uZmlnOiBUcmFuc2xvY29Db25maWcsXG4gICAgQEluamVjdChUUkFOU0xPQ09fRkFMTEJBQ0tfU1RSQVRFR1kpIHByaXZhdGUgZmFsbGJhY2tTdHJhdGVneTogVHJhbnNsb2NvRmFsbGJhY2tTdHJhdGVneVxuICApIHtcbiAgICBpZiAoIXRoaXMubG9hZGVyKSB7XG4gICAgICB0aGlzLmxvYWRlciA9IG5ldyBEZWZhdWx0TG9hZGVyKHRoaXMudHJhbnNsYXRpb25zKTtcbiAgICB9XG4gICAgc2VydmljZSA9IHRoaXM7XG4gICAgdGhpcy5tZXJnZWRDb25maWcgPSBtZXJnZUNvbmZpZyhkZWZhdWx0Q29uZmlnLCB1c2VyQ29uZmlnKTtcblxuICAgIHRoaXMuc2V0QXZhaWxhYmxlTGFuZ3ModGhpcy5tZXJnZWRDb25maWcuYXZhaWxhYmxlTGFuZ3MpO1xuICAgIHRoaXMuc2V0RmFsbGJhY2tMYW5nRm9yTWlzc2luZ1RyYW5zbGF0aW9uKHRoaXMubWVyZ2VkQ29uZmlnKTtcbiAgICB0aGlzLnNldERlZmF1bHRMYW5nKHRoaXMubWVyZ2VkQ29uZmlnLmRlZmF1bHRMYW5nKTtcbiAgICB0aGlzLmxhbmcgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PHN0cmluZz4odGhpcy5nZXREZWZhdWx0TGFuZygpKTtcbiAgICAvLyBEb24ndCB1c2UgZGlzdGluY3RVbnRpbENoYW5nZWQgYXMgd2UgbmVlZCB0aGUgYWJpbGl0eSB0byB1cGRhdGVcbiAgICAvLyB0aGUgdmFsdWUgd2hlbiB1c2luZyBzZXRUcmFuc2xhdGlvbiBvciBzZXRUcmFuc2xhdGlvbktleXNcbiAgICB0aGlzLmxhbmdDaGFuZ2VzJCA9IHRoaXMubGFuZy5hc09ic2VydmFibGUoKTtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gd2UgaGF2ZSBhIGZhaWx1cmUsIHdlIHdhbnQgdG8gZGVmaW5lIHRoZSBuZXh0IGxhbmd1YWdlIHRoYXQgc3VjY2VlZGVkIGFzIHRoZSBhY3RpdmVcbiAgICAgKi9cbiAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IHRoaXMuZXZlbnRzJC5zdWJzY3JpYmUoZSA9PiB7XG4gICAgICBpZiAoZS50eXBlID09PSAndHJhbnNsYXRpb25Mb2FkU3VjY2VzcycgJiYgZS53YXNGYWlsdXJlKSB7XG4gICAgICAgIC8vIEhhbmRsZSBzY29wZWQgbGFuZ1xuICAgICAgICBjb25zdCBsYW5nID0gZ2V0TGFuZ0Zyb21TY29wZShlLnBheWxvYWQubGFuZyk7XG4gICAgICAgIHRoaXMuc2V0QWN0aXZlTGFuZyhsYW5nKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGdldCBjb25maWcoKTogVHJhbnNsb2NvQ29uZmlnIHtcbiAgICByZXR1cm4gdGhpcy5tZXJnZWRDb25maWc7XG4gIH1cblxuICBnZXREZWZhdWx0TGFuZygpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZhdWx0TGFuZztcbiAgfVxuXG4gIHNldERlZmF1bHRMYW5nKGxhbmc6IHN0cmluZykge1xuICAgIHRoaXMuZGVmYXVsdExhbmcgPSBsYW5nO1xuICB9XG5cbiAgZ2V0QWN0aXZlTGFuZygpIHtcbiAgICByZXR1cm4gdGhpcy5sYW5nLmdldFZhbHVlKCk7XG4gIH1cblxuICBzZXRBY3RpdmVMYW5nKGxhbmc6IHN0cmluZykge1xuICAgIHRoaXMucGFyc2VyLm9uTGFuZ0NoYW5nZWQgJiYgdGhpcy5wYXJzZXIub25MYW5nQ2hhbmdlZChsYW5nKTtcbiAgICB0aGlzLmxhbmcubmV4dChsYW5nKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldEF2YWlsYWJsZUxhbmdzKGxhbmdzOiBBdmFpbGFibGVMYW5ncykge1xuICAgIHRoaXMuYXZhaWxhYmxlTGFuZ3MgPSBsYW5ncztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBhdmFpbGFibGUgbGFuZ3VhZ2VzLlxuICAgKlxuICAgKiBAcmV0dXJuc1xuICAgKiBBbiBhcnJheSBvZiB0aGUgYXZhaWxhYmxlIGxhbmd1YWdlcy4gQ2FuIGJlIGVpdGhlciBhIGBzdHJpbmdbXWAgb3IgYSBgeyBpZDogc3RyaW5nOyBsYWJlbDogc3RyaW5nIH1bXWBcbiAgICogZGVwZW5kaW5nIG9uIGhvdyB0aGUgYXZhaWxhYmxlIGxhbmd1YWdlcyBhcmUgc2V0IGluIHlvdXIgbW9kdWxlLlxuICAgKi9cbiAgZ2V0QXZhaWxhYmxlTGFuZ3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXZhaWxhYmxlTGFuZ3M7XG4gIH1cblxuICBsb2FkKHBhdGg6IHN0cmluZywgb3B0aW9uczogTG9hZE9wdGlvbnMgPSB7fSk6IE9ic2VydmFibGU8VHJhbnNsYXRpb24+IHtcbiAgICBpZiAodGhpcy5jYWNoZS5oYXMocGF0aCkgPT09IGZhbHNlKSB7XG4gICAgICBsZXQgbG9hZFRyYW5zbGF0aW9uOiBPYnNlcnZhYmxlPFRyYW5zbGF0aW9uIHwgeyB0cmFuc2xhdGlvbjogVHJhbnNsYXRpb247IGxhbmc6IHN0cmluZyB9W10+O1xuICAgICAgY29uc3QgaXNTY29wZSA9IHRoaXMuX2lzTGFuZ1Njb3BlZChwYXRoKTtcbiAgICAgIGNvbnN0IHNjb3BlID0gaXNTY29wZSA/IGdldFNjb3BlRnJvbUxhbmcocGF0aCkgOiBudWxsO1xuICAgICAgaWYgKHRoaXMudXNlRmFsbGJhY2tUcmFuc2xhdGlvbihwYXRoKSkge1xuICAgICAgICAvLyBpZiB0aGUgcGF0aCBpcyBzY29wZSB0aGUgZmFsbGJhY2sgc2hvdWxkIGJlIGBzY29wZS9mYWxsYmFja0xhbmdgO1xuICAgICAgICBjb25zdCBmYWxsYmFjayA9IGlzU2NvcGUgPyBgJHtzY29wZX0vJHt0aGlzLmZpcnN0RmFsbGJhY2tMYW5nfWAgOiB0aGlzLmZpcnN0RmFsbGJhY2tMYW5nO1xuXG4gICAgICAgIGNvbnN0IGxvYWRlcnMgPSBnZXRGYWxsYmFja3NMb2FkZXJzKHBhdGgsIGZhbGxiYWNrLCB0aGlzLmxvYWRlciwgb3B0aW9ucy5pbmxpbmVMb2FkZXIsIHsgc2NvcGUgfSk7XG4gICAgICAgIGxvYWRUcmFuc2xhdGlvbiA9IGZvcmtKb2luKGxvYWRlcnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbG9hZGVyID0gcmVzb2x2ZUxvYWRlcihwYXRoLCB0aGlzLmxvYWRlciwgb3B0aW9ucy5pbmxpbmVMb2FkZXIsIHsgc2NvcGUgfSk7XG4gICAgICAgIGxvYWRUcmFuc2xhdGlvbiA9IGZyb20obG9hZGVyKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbG9hZCQgPSBsb2FkVHJhbnNsYXRpb24ucGlwZShcbiAgICAgICAgcmV0cnkodGhpcy5jb25maWcuZmFpbGVkUmV0cmllcyksXG4gICAgICAgIHRhcCh0cmFuc2xhdGlvbiA9PiB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNsYXRpb24pKSB7XG4gICAgICAgICAgICB0cmFuc2xhdGlvbi5mb3JFYWNoKHQgPT4ge1xuICAgICAgICAgICAgICB0aGlzLmhhbmRsZVN1Y2Nlc3ModC5sYW5nLCB0LnRyYW5zbGF0aW9uKTtcbiAgICAgICAgICAgICAgLy8gU2F2ZSB0aGUgZmFsbGJhY2sgaW4gY2FjaGUgc28gd2UnbGwgbm90IGNyZWF0ZSBhIHJlZHVuZGFudCByZXF1ZXN0XG4gICAgICAgICAgICAgIGlmICh0LmxhbmcgIT09IHBhdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlLnNldCh0LmxhbmcsIG9mKHt9KSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmhhbmRsZVN1Y2Nlc3MocGF0aCwgdHJhbnNsYXRpb24pO1xuICAgICAgICB9KSxcbiAgICAgICAgY2F0Y2hFcnJvcihlcnJvciA9PiB7XG4gICAgICAgICAgaWYgKCF0aGlzLm1lcmdlZENvbmZpZy5wcm9kTW9kZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3Igd2hpbGUgdHJ5aW5nIHRvIGxvYWQgXCIke3BhdGh9XCJgLCBlcnJvcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlRmFpbHVyZShwYXRoLCBvcHRpb25zKTtcbiAgICAgICAgfSksXG4gICAgICAgIHNoYXJlUmVwbGF5KDEpXG4gICAgICApO1xuXG4gICAgICB0aGlzLmNhY2hlLnNldChwYXRoLCBsb2FkJCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2FjaGUuZ2V0KHBhdGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGluc3RhbnQgdHJhbnNsYXRlZCB2YWx1ZSBvZiBhIGtleVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB0cmFuc2xhdGU8c3RyaW5nPignaGVsbG8nKVxuICAgKiB0cmFuc2xhdGUoJ2hlbGxvJywgeyB2YWx1ZTogJ3ZhbHVlJyB9KVxuICAgKiB0cmFuc2xhdGU8c3RyaW5nW10+KFsnaGVsbG8nLCAna2V5J10pXG4gICAqIHRyYW5zbGF0ZSgnaGVsbG8nLCB7IH0sICdlbicpXG4gICAqIHRyYW5zbGF0ZSgnc2NvcGUuc29tZUtleScsIHsgfSwgJ2VuJylcbiAgICovXG4gIHRyYW5zbGF0ZTxUID0gYW55PihrZXk6IFRyYW5zbGF0ZVBhcmFtcywgcGFyYW1zOiBIYXNoTWFwID0ge30sIGxhbmcgPSB0aGlzLmdldEFjdGl2ZUxhbmcoKSk6IFQge1xuICAgIGlmICgha2V5KSByZXR1cm4ga2V5IGFzIGFueTtcblxuICAgIGNvbnN0IHsgc2NvcGUsIHJlc29sdmVMYW5nIH0gPSB0aGlzLnJlc29sdmVMYW5nQW5kU2NvcGUobGFuZyk7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShrZXkpKSB7XG4gICAgICByZXR1cm4ga2V5Lm1hcChrID0+IHRoaXMudHJhbnNsYXRlKHNjb3BlID8gYCR7c2NvcGV9LiR7a31gIDogaywgcGFyYW1zLCByZXNvbHZlTGFuZykpIGFzIGFueTtcbiAgICB9XG5cbiAgICBrZXkgPSBzY29wZSA/IGAke3Njb3BlfS4ke2tleX1gIDoga2V5O1xuXG4gICAgY29uc3QgdHJhbnNsYXRpb24gPSB0aGlzLmdldFRyYW5zbGF0aW9uKHJlc29sdmVMYW5nKTtcbiAgICBjb25zdCB2YWx1ZSA9IHRyYW5zbGF0aW9uW2tleV07XG5cbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5faGFuZGxlTWlzc2luZ0tleShrZXksIHZhbHVlLCBwYXJhbXMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnBhcnNlci50cmFuc3BpbGUodmFsdWUsIHBhcmFtcywgdHJhbnNsYXRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHRyYW5zbGF0ZWQgdmFsdWUgb2YgYSBrZXkgYXMgb2JzZXJ2YWJsZVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBzZWxlY3RUcmFuc2xhdGU8c3RyaW5nPignaGVsbG8nKS5zdWJzY3JpYmUodmFsdWUgPT4gLi4uKVxuICAgKiBzZWxlY3RUcmFuc2xhdGU8c3RyaW5nPignaGVsbG8nLCB7fSwgJ2VzJykuc3Vic2NyaWJlKHZhbHVlID0+IC4uLilcbiAgICogc2VsZWN0VHJhbnNsYXRlPHN0cmluZz4oJ2hlbGxvJywge30sICd0b2RvcycpLnN1YnNjcmliZSh2YWx1ZSA9PiAuLi4pXG4gICAqIHNlbGVjdFRyYW5zbGF0ZTxzdHJpbmc+KCdoZWxsbycsIHt9LCB7IHNjb3BlOiAndG9kb3MnIH0pLnN1YnNjcmliZSh2YWx1ZSA9PiAuLi4pXG4gICAqXG4gICAqL1xuICBzZWxlY3RUcmFuc2xhdGU8VCA9IGFueT4oXG4gICAga2V5OiBUcmFuc2xhdGVQYXJhbXMsXG4gICAgcGFyYW1zPzogSGFzaE1hcCxcbiAgICBsYW5nPzogc3RyaW5nIHwgVHJhbnNsb2NvU2NvcGUsXG4gICAgX2lzT2JqZWN0ID0gZmFsc2VcbiAgKTogT2JzZXJ2YWJsZTxUPiB7XG4gICAgbGV0IGlubGluZUxvYWRlciA9IG51bGw7XG4gICAgY29uc3QgbG9hZCA9IChsYW5nLCBvcHRpb25zPzogTG9hZE9wdGlvbnMpID0+XG4gICAgICB0aGlzLmxvYWQobGFuZywgb3B0aW9ucykucGlwZShcbiAgICAgICAgbWFwKCgpID0+IChfaXNPYmplY3QgPyB0aGlzLnRyYW5zbGF0ZU9iamVjdChrZXksIHBhcmFtcywgbGFuZykgOiB0aGlzLnRyYW5zbGF0ZShrZXksIHBhcmFtcywgbGFuZykpKVxuICAgICAgKTtcbiAgICBpZiAoaXNOaWwobGFuZykpIHtcbiAgICAgIHJldHVybiB0aGlzLmxhbmdDaGFuZ2VzJC5waXBlKHN3aXRjaE1hcChsYW5nID0+IGxvYWQobGFuZykpKTtcbiAgICB9XG5cbiAgICBpZiAoaXNTY29wZU9iamVjdChsYW5nKSkge1xuICAgICAgLy8gaXQncyBhIHNjb3BlIG9iamVjdC5cbiAgICAgIGNvbnN0IHByb3ZpZGVyU2NvcGUgPSBsYW5nIGFzIFByb3ZpZGVyU2NvcGU7XG4gICAgICBsYW5nID0gcHJvdmlkZXJTY29wZS5zY29wZTtcbiAgICAgIGlubGluZUxvYWRlciA9IHJlc29sdmVJbmxpbmVMb2FkZXIocHJvdmlkZXJTY29wZSwgcHJvdmlkZXJTY29wZS5zY29wZSk7XG4gICAgfVxuXG4gICAgbGFuZyA9IGxhbmcgYXMgc3RyaW5nO1xuICAgIGlmICh0aGlzLmlzTGFuZyhsYW5nKSB8fCB0aGlzLmlzU2NvcGVXaXRoTGFuZyhsYW5nKSkge1xuICAgICAgcmV0dXJuIGxvYWQobGFuZyk7XG4gICAgfVxuICAgIC8vIGl0J3MgYSBzY29wZVxuICAgIGNvbnN0IHNjb3BlID0gbGFuZztcbiAgICByZXR1cm4gdGhpcy5sYW5nQ2hhbmdlcyQucGlwZShzd2l0Y2hNYXAobGFuZyA9PiBsb2FkKGAke3Njb3BlfS8ke2xhbmd9YCwgeyBpbmxpbmVMb2FkZXIgfSkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBzY29wZSB3aXRoIGxhbmdcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdG9kb3MvZW4gPT4gdHJ1ZVxuICAgKiB0b2RvcyA9PiBmYWxzZVxuICAgKi9cbiAgcHJpdmF0ZSBpc1Njb3BlV2l0aExhbmcobGFuZzogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNMYW5nKGdldExhbmdGcm9tU2NvcGUobGFuZykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zbGF0ZSB0aGUgZ2l2ZW4gcGF0aCB0aGF0IHJldHVybnMgYW4gb2JqZWN0XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHNlcnZpY2UudHJhbnNsYXRlT2JqZWN0KCdwYXRoLnRvLm9iamVjdCcsIHsnc3VicGF0aCc6IHsgdmFsdWU6ICdzb21lVmFsdWUnfX0pID0+IHJldHVybnMgdHJhbnNsYXRlZCBvYmplY3RcbiAgICpcbiAgICovXG4gIHRyYW5zbGF0ZU9iamVjdDxUID0gYW55PihrZXk6IHN0cmluZywgcGFyYW1zPzogSGFzaE1hcCwgbGFuZz86IHN0cmluZyk6IFQ7XG4gIHRyYW5zbGF0ZU9iamVjdDxUID0gYW55PihrZXk6IHN0cmluZ1tdLCBwYXJhbXM/OiBIYXNoTWFwLCBsYW5nPzogc3RyaW5nKTogVFtdO1xuICB0cmFuc2xhdGVPYmplY3Q8VCA9IGFueT4oa2V5OiBUcmFuc2xhdGVQYXJhbXMsIHBhcmFtcz86IEhhc2hNYXAsIGxhbmc/OiBzdHJpbmcpOiBUIHwgVFtdO1xuICB0cmFuc2xhdGVPYmplY3Q8VCA9IGFueT4oa2V5OiBIYXNoTWFwIHwgTWFwPHN0cmluZywgSGFzaE1hcD4sIHBhcmFtcz86IG51bGwsIGxhbmc/OiBzdHJpbmcpOiBUW107XG4gIHRyYW5zbGF0ZU9iamVjdDxUID0gYW55PihrZXk6IFRyYW5zbGF0ZU9iamVjdFBhcmFtcywgcGFyYW1zPzogSGFzaE1hcCwgbGFuZyA9IHRoaXMuZ2V0QWN0aXZlTGFuZygpKTogVCB8IFRbXSB7XG4gICAgaWYgKGlzU3RyaW5nKGtleSkgfHwgQXJyYXkuaXNBcnJheShrZXkpKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShrZXkpKSB7XG4gICAgICAgIHJldHVybiBrZXkubWFwKGsgPT4gdGhpcy50cmFuc2xhdGVPYmplY3Qoc2NvcGUgPyBgJHtzY29wZX0uJHtrfWAgOiBrLCBwYXJhbXMsIHJlc29sdmVMYW5nKSkgYXMgYW55O1xuICAgICAgfVxuICAgICAgY29uc3QgeyByZXNvbHZlTGFuZywgc2NvcGUgfSA9IHRoaXMucmVzb2x2ZUxhbmdBbmRTY29wZShsYW5nKTtcblxuICAgICAgY29uc3QgdHJhbnNsYXRpb24gPSB0aGlzLmdldFRyYW5zbGF0aW9uKHJlc29sdmVMYW5nKTtcbiAgICAgIGtleSA9IHNjb3BlID8gYCR7c2NvcGV9LiR7a2V5fWAgOiBrZXk7XG5cbiAgICAgIGNvbnN0IHZhbHVlID0gdW5mbGF0dGVuKHRoaXMuZ2V0T2JqZWN0QnlLZXkodHJhbnNsYXRpb24sIGtleSkpO1xuICAgICAgLyogSWYgYW4gZW1wdHkgb2JqZWN0IHdhcyByZXR1cm5lZCB3ZSB3YW50IHRvIHRyeSBhbmQgdHJhbnNsYXRlIHRoZSBrZXkgYXMgYSBzdHJpbmcgYW5kIG5vdCBhbiBvYmplY3QgKi9cbiAgICAgIHJldHVybiBpc0VtcHR5KHZhbHVlKSA/IHRoaXMudHJhbnNsYXRlKGtleSwgcGFyYW1zLCBsYW5nKSA6IHRoaXMucGFyc2VyLnRyYW5zcGlsZSh2YWx1ZSwgcGFyYW1zLCB0cmFuc2xhdGlvbik7XG4gICAgfVxuXG4gICAgY29uc3QgdHJhbnNsYXRpb25zOiBUW10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtfa2V5LCBfcGFyYW1zXSBvZiB0aGlzLmdldEVudHJpZXMoa2V5KSkge1xuICAgICAgdHJhbnNsYXRpb25zLnB1c2godGhpcy50cmFuc2xhdGVPYmplY3QoX2tleSwgX3BhcmFtcywgbGFuZykpO1xuICAgIH1cblxuICAgIHJldHVybiB0cmFuc2xhdGlvbnM7XG4gIH1cblxuICBzZWxlY3RUcmFuc2xhdGVPYmplY3Q8VCA9IGFueT4oa2V5OiBzdHJpbmcsIHBhcmFtcz86IEhhc2hNYXAsIGxhbmc/OiBzdHJpbmcpOiBPYnNlcnZhYmxlPFQ+O1xuICBzZWxlY3RUcmFuc2xhdGVPYmplY3Q8VCA9IGFueT4oa2V5OiBzdHJpbmdbXSwgcGFyYW1zPzogSGFzaE1hcCwgbGFuZz86IHN0cmluZyk6IE9ic2VydmFibGU8VFtdPjtcbiAgc2VsZWN0VHJhbnNsYXRlT2JqZWN0PFQgPSBhbnk+KGtleTogSGFzaE1hcCB8IE1hcDxzdHJpbmcsIEhhc2hNYXA+LCBwYXJhbXM/OiBudWxsLCBsYW5nPzogc3RyaW5nKTogT2JzZXJ2YWJsZTxUW10+O1xuICBzZWxlY3RUcmFuc2xhdGVPYmplY3Q8VCA9IGFueT4oXG4gICAga2V5OiBUcmFuc2xhdGVPYmplY3RQYXJhbXMsXG4gICAgcGFyYW1zPzogSGFzaE1hcCxcbiAgICBsYW5nPzogc3RyaW5nXG4gICk6IE9ic2VydmFibGU8VD4gfCBPYnNlcnZhYmxlPFRbXT4ge1xuICAgIGlmIChpc1N0cmluZyhrZXkpIHx8IEFycmF5LmlzQXJyYXkoa2V5KSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0VHJhbnNsYXRlPFQ+KGtleSwgcGFyYW1zLCBsYW5nLCB0cnVlKTtcbiAgICB9XG5cbiAgICBjb25zdCBbW2ZpcnN0S2V5LCBmaXJzdFBhcmFtc10sIC4uLnJlc3RdID0gdGhpcy5nZXRFbnRyaWVzKGtleSk7XG5cbiAgICAvKiBJbiBvcmRlciB0byBhdm9pZCBzdWJzY3JpYmluZyBtdWx0aXBsZSB0aW1lcyB0byB0aGUgbG9hZCBsYW5ndWFnZSBldmVudCBieSBjYWxsaW5nIHNlbGVjdFRyYW5zbGF0ZU9iamVjdCBmb3IgZWFjaCBwYWlyLFxuICAgICAqIHdlIGxpc3RlbiB0byB3aGVuIHRoZSBmaXJzdCBrZXkgaGFzIGJlZW4gdHJhbnNsYXRlZCAodGhlIGxhbmd1YWdlIGlzIGxvYWRlZCkgYW5kIHRyYW5zbGF0ZSB0aGUgcmVzdCBzeW5jaHJvbm91c2x5ICovXG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0VHJhbnNsYXRlT2JqZWN0PFQ+KGZpcnN0S2V5LCBmaXJzdFBhcmFtcywgbGFuZykucGlwZShcbiAgICAgIG1hcCh2YWx1ZSA9PiB7XG4gICAgICAgIGNvbnN0IHRyYW5zbGF0aW9ucyA9IFt2YWx1ZV07XG4gICAgICAgIGZvciAoY29uc3QgW19rZXksIF9wYXJhbXNdIG9mIHJlc3QpIHtcbiAgICAgICAgICB0cmFuc2xhdGlvbnMucHVzaCh0aGlzLnRyYW5zbGF0ZU9iamVjdDxUPihfa2V5LCBfcGFyYW1zLCBsYW5nKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJhbnNsYXRpb25zO1xuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYW4gb2JqZWN0IG9mIHRyYW5zbGF0aW9ucyBmb3IgYSBnaXZlbiBsYW5ndWFnZVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBnZXRUcmFuc2xhdGlvbigpXG4gICAqIGdldFRyYW5zbGF0aW9uKCdlbicpXG4gICAqIGdldFRyYW5zbGF0aW9uKCdhZG1pbi1wYWdlL2VuJylcbiAgICovXG4gIGdldFRyYW5zbGF0aW9uKCk6IE1hcDxzdHJpbmcsIFRyYW5zbGF0aW9uPjtcbiAgZ2V0VHJhbnNsYXRpb24obGFuZ09yU2NvcGU6IHN0cmluZyk6IFRyYW5zbGF0aW9uO1xuICBnZXRUcmFuc2xhdGlvbihsYW5nT3JTY29wZT86IHN0cmluZyk6IE1hcDxzdHJpbmcsIFRyYW5zbGF0aW9uPiB8IFRyYW5zbGF0aW9uIHtcbiAgICBpZiAobGFuZ09yU2NvcGUpIHtcbiAgICAgIGlmICh0aGlzLmlzTGFuZyhsYW5nT3JTY29wZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRpb25zLmdldChsYW5nT3JTY29wZSkgfHwge307XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGlzIGEgc2NvcGUsIGJ1aWxkIHRoZSBzY29wZSB2YWx1ZSBmcm9tIHRoZSB0cmFuc2xhdGlvbiBvYmplY3RcbiAgICAgICAgY29uc3QgeyBzY29wZSwgcmVzb2x2ZUxhbmcgfSA9IHRoaXMucmVzb2x2ZUxhbmdBbmRTY29wZShsYW5nT3JTY29wZSk7XG4gICAgICAgIGNvbnN0IHRyYW5zbGF0aW9uID0gdGhpcy50cmFuc2xhdGlvbnMuZ2V0KHJlc29sdmVMYW5nKSB8fCB7fTtcblxuICAgICAgICByZXR1cm4gdGhpcy5nZXRPYmplY3RCeUtleSh0cmFuc2xhdGlvbiwgc2NvcGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnRyYW5zbGF0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuIG9iamVjdCBvZiB0cmFuc2xhdGlvbnMgZm9yIGEgZ2l2ZW4gbGFuZ3VhZ2VcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogc2VsZWN0VHJhbnNsYXRpb24oKS5zdWJzY3JpYmUoKSAtIHdpbGwgcmV0dXJuIHRoZSBjdXJyZW50IGxhbmcgdHJhbnNsYXRpb25cbiAgICogc2VsZWN0VHJhbnNsYXRpb24oJ2VzJykuc3Vic2NyaWJlKClcbiAgICogc2VsZWN0VHJhbnNsYXRpb24oJ2FkbWluLXBhZ2UnKS5zdWJzY3JpYmUoKSAtIHdpbGwgcmV0dXJuIHRoZSBjdXJyZW50IGxhbmcgc2NvcGUgdHJhbnNsYXRpb25cbiAgICogc2VsZWN0VHJhbnNsYXRpb24oJ2FkbWluLXBhZ2UvZXMnKS5zdWJzY3JpYmUoKVxuICAgKi9cbiAgc2VsZWN0VHJhbnNsYXRpb24obGFuZz86IHN0cmluZyk6IE9ic2VydmFibGU8VHJhbnNsYXRpb24+IHtcbiAgICBsZXQgbGFuZ3VhZ2UkID0gdGhpcy5sYW5nQ2hhbmdlcyQ7XG4gICAgaWYgKGxhbmcpIHtcbiAgICAgIGNvbnN0IHNjb3BlTGFuZ1NwZWNpZmllZCA9IGdldExhbmdGcm9tU2NvcGUobGFuZykgIT09IGxhbmc7XG4gICAgICBpZiAodGhpcy5pc0xhbmcobGFuZykgfHwgc2NvcGVMYW5nU3BlY2lmaWVkKSB7XG4gICAgICAgIGxhbmd1YWdlJCA9IG9mKGxhbmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFuZ3VhZ2UkID0gdGhpcy5sYW5nQ2hhbmdlcyQucGlwZShtYXAoY3VycmVudExhbmcgPT4gYCR7bGFuZ30vJHtjdXJyZW50TGFuZ31gKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxhbmd1YWdlJC5waXBlKHN3aXRjaE1hcChsYW5ndWFnZSA9PiB0aGlzLmxvYWQobGFuZ3VhZ2UpLnBpcGUobWFwKCgpID0+IHRoaXMuZ2V0VHJhbnNsYXRpb24obGFuZ3VhZ2UpKSkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIG9yIG1lcmdlIGEgZ2l2ZW4gdHJhbnNsYXRpb24gb2JqZWN0IHRvIGN1cnJlbnQgbGFuZ1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBzZXRUcmFuc2xhdGlvbih7IC4uLiB9KVxuICAgKiBzZXRUcmFuc2xhdGlvbih7IC4uLiB9LCAnZW4nKVxuICAgKiBzZXRUcmFuc2xhdGlvbih7IC4uLiB9LCAnZXMnLCB7IG1lcmdlOiBmYWxzZSB9IClcbiAgICogc2V0VHJhbnNsYXRpb24oeyAuLi4gfSwgJ3RvZG9zL2VuJywgeyBtZXJnZTogZmFsc2UgfSApXG4gICAqL1xuICBzZXRUcmFuc2xhdGlvbih0cmFuc2xhdGlvbjogVHJhbnNsYXRpb24sIGxhbmcgPSB0aGlzLmdldEFjdGl2ZUxhbmcoKSwgb3B0aW9uczogU2V0VHJhbnNsYXRpb25PcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBkZWZhdWx0cyA9IHsgbWVyZ2U6IHRydWUsIGVtaXRDaGFuZ2U6IHRydWUgfTtcbiAgICBjb25zdCBtZXJnZWRPcHRpb25zID0geyAuLi5kZWZhdWx0cywgLi4ub3B0aW9ucyB9O1xuICAgIGNvbnN0IHNjb3BlID0gZ2V0U2NvcGVGcm9tTGFuZyhsYW5nKTtcblxuICAgIC8qKlxuICAgICAqIElmIHRoaXMgaXNuJ3QgYSBzY29wZSB3ZSB1c2UgdGhlIHdob2xlIHRyYW5zbGF0aW9uIGFzIGlzXG4gICAgICogb3RoZXJ3aXNlIHdlIG5lZWQgdG8gZmxhdCB0aGUgc2NvcGUgYW5kIHVzZSBpdFxuICAgICAqL1xuICAgIGxldCBmbGF0dGVuU2NvcGVPclRyYW5zbGF0aW9uID0gdHJhbnNsYXRpb247XG5cbiAgICAvLyBNZXJnZWQgdGhlIHNjb3BlZCBsYW5ndWFnZSBpbnRvIHRoZSBhY3RpdmUgbGFuZ3VhZ2VcbiAgICBpZiAoc2NvcGUpIHtcbiAgICAgIGNvbnN0IGtleSA9IHRoaXMuZ2V0TWFwcGVkU2NvcGUoc2NvcGUpO1xuICAgICAgZmxhdHRlblNjb3BlT3JUcmFuc2xhdGlvbiA9IGZsYXR0ZW4oeyBba2V5XTogdHJhbnNsYXRpb24gfSk7XG4gICAgfVxuXG4gICAgY29uc3QgY3VycmVudExhbmcgPSBzY29wZSA/IGdldExhbmdGcm9tU2NvcGUobGFuZykgOiBsYW5nO1xuXG4gICAgY29uc3QgbWVyZ2VkVHJhbnNsYXRpb24gPSB7XG4gICAgICAuLi4obWVyZ2VkT3B0aW9ucy5tZXJnZSAmJiB0aGlzLmdldFRyYW5zbGF0aW9uKGN1cnJlbnRMYW5nKSksXG4gICAgICAuLi5mbGF0dGVuU2NvcGVPclRyYW5zbGF0aW9uXG4gICAgfTtcblxuICAgIGNvbnN0IGZsYXR0ZW5UcmFuc2xhdGlvbiA9IHRoaXMubWVyZ2VkQ29uZmlnLmZsYXR0ZW4uYW90ID8gbWVyZ2VkVHJhbnNsYXRpb24gOiBmbGF0dGVuKG1lcmdlZFRyYW5zbGF0aW9uKTtcbiAgICBjb25zdCB3aXRoSG9vayA9IHRoaXMuaW50ZXJjZXB0b3IucHJlU2F2ZVRyYW5zbGF0aW9uKGZsYXR0ZW5UcmFuc2xhdGlvbiwgY3VycmVudExhbmcpO1xuICAgIHRoaXMudHJhbnNsYXRpb25zLnNldChjdXJyZW50TGFuZywgd2l0aEhvb2spO1xuICAgIG1lcmdlZE9wdGlvbnMuZW1pdENoYW5nZSAmJiB0aGlzLnNldEFjdGl2ZUxhbmcodGhpcy5nZXRBY3RpdmVMYW5nKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdHJhbnNsYXRpb24ga2V5IHdpdGggZ2l2ZW4gdmFsdWVcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogc2V0VHJhbnNsYXRpb25LZXkoJ2tleScsICd2YWx1ZScpXG4gICAqIHNldFRyYW5zbGF0aW9uS2V5KCdrZXkubmVzdGVkJywgJ3ZhbHVlJylcbiAgICogc2V0VHJhbnNsYXRpb25LZXkoJ2tleS5uZXN0ZWQnLCAndmFsdWUnLCAnZW4nKVxuICAgKiBzZXRUcmFuc2xhdGlvbktleSgna2V5Lm5lc3RlZCcsICd2YWx1ZScsICdlbicsIHsgZW1pdENoYW5nZTogZmFsc2UgfSApXG4gICAqL1xuICBzZXRUcmFuc2xhdGlvbktleShcbiAgICBrZXk6IHN0cmluZyxcbiAgICB2YWx1ZTogc3RyaW5nLFxuICAgIGxhbmcgPSB0aGlzLmdldEFjdGl2ZUxhbmcoKSxcbiAgICAvLyBUb2RvOiBVc2UgT21pdCBhbmQgbWVyZ2Ugb3B0aW9ucyBhbmQgbGFuZyB0byBvbmUgb2JqZWN0IGluIHYzXG4gICAgb3B0aW9uczogeyBlbWl0Q2hhbmdlPzogU2V0VHJhbnNsYXRpb25PcHRpb25zWydlbWl0Q2hhbmdlJ10gfSA9IHt9XG4gICkge1xuICAgIGNvbnN0IHdpdGhIb29rID0gdGhpcy5pbnRlcmNlcHRvci5wcmVTYXZlVHJhbnNsYXRpb25LZXkoa2V5LCB2YWx1ZSwgbGFuZyk7XG4gICAgY29uc3QgbmV3VmFsdWUgPSB7XG4gICAgICBba2V5XTogd2l0aEhvb2tcbiAgICB9O1xuXG4gICAgdGhpcy5zZXRUcmFuc2xhdGlvbihuZXdWYWx1ZSwgbGFuZywgeyAuLi5vcHRpb25zLCBtZXJnZTogdHJ1ZSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBmYWxsYmFjayBsYW5nIGZvciB0aGUgY3VycmVudGx5IGFjdGl2ZSBsYW5ndWFnZVxuICAgKiBAcGFyYW0gZmFsbGJhY2tMYW5nXG4gICAqL1xuICBzZXRGYWxsYmFja0xhbmdGb3JNaXNzaW5nVHJhbnNsYXRpb24oeyBmYWxsYmFja0xhbmcgfTogUGljazxUcmFuc2xvY29Db25maWcsICdmYWxsYmFja0xhbmcnPik6IHZvaWQge1xuICAgIGNvbnN0IGxhbmcgPSBBcnJheS5pc0FycmF5KGZhbGxiYWNrTGFuZykgPyBmYWxsYmFja0xhbmdbMF0gOiBmYWxsYmFja0xhbmc7XG4gICAgaWYgKHRoaXMudXNlRmFsbGJhY2tUcmFuc2xhdGlvbihsYW5nKSAmJiBmYWxsYmFja0xhbmcpIHtcbiAgICAgIHRoaXMuZmlyc3RGYWxsYmFja0xhbmcgPSBsYW5nO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9oYW5kbGVNaXNzaW5nS2V5KGtleTogc3RyaW5nLCB2YWx1ZTogYW55LCBwYXJhbXM/OiBIYXNoTWFwKSB7XG4gICAgaWYgKHRoaXMuY29uZmlnLm1pc3NpbmdIYW5kbGVyLmFsbG93RW1wdHkgJiYgdmFsdWUgPT09ICcnKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudXNlRmFsbGJhY2tUcmFuc2xhdGlvbigpICYmICF0aGlzLmlzUmVzb2x2ZWRNaXNzaW5nT25jZSkge1xuICAgICAgLy8gV2UgbmVlZCB0byBzZXQgaXQgdG8gdHJ1ZSB0byBwcmV2ZW50IGEgbG9vcFxuICAgICAgdGhpcy5pc1Jlc29sdmVkTWlzc2luZ09uY2UgPSB0cnVlO1xuICAgICAgY29uc3QgZmFsbGJhY2tWYWx1ZSA9IHRoaXMudHJhbnNsYXRlKGtleSwgcGFyYW1zLCB0aGlzLmZpcnN0RmFsbGJhY2tMYW5nKTtcbiAgICAgIHRoaXMuaXNSZXNvbHZlZE1pc3NpbmdPbmNlID0gZmFsc2U7XG4gICAgICByZXR1cm4gZmFsbGJhY2tWYWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5taXNzaW5nSGFuZGxlci5oYW5kbGUoa2V5LCB0aGlzLmdldE1pc3NpbmdIYW5kbGVyRGF0YSgpLCBwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2lzTGFuZ1Njb3BlZChsYW5nOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBdmFpbGFibGVMYW5nc0lkcygpLmluZGV4T2YobGFuZykgPT09IC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIGdpdmVuIHN0cmluZyBpcyBvbmUgb2YgdGhlIHNwZWNpZmllZCBhdmFpbGFibGUgbGFuZ3VhZ2VzLlxuICAgKiBAcmV0dXJuc1xuICAgKiBUcnVlIGlmIHRoZSBnaXZlbiBzdHJpbmcgaXMgYW4gYXZhaWxhYmxlIGxhbmd1YWdlLlxuICAgKiBGYWxzZSBpZiB0aGUgZ2l2ZW4gc3RyaW5nIGlzIG5vdCBhbiBhdmFpbGFibGUgbGFuZ3VhZ2UuXG4gICAqL1xuICBpc0xhbmcobGFuZzogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QXZhaWxhYmxlTGFuZ3NJZHMoKS5pbmRleE9mKGxhbmcpICE9PSAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICpcbiAgICogV2UgYWx3YXlzIHdhbnQgdG8gbWFrZSBzdXJlIHRoZSBnbG9iYWwgbGFuZyBpcyBsb2FkZWRcbiAgICogYmVmb3JlIGxvYWRpbmcgdGhlIHNjb3BlIHNpbmNlIHlvdSBjYW4gYWNjZXNzIGJvdGggdmlhIHRoZSBwaXBlL2RpcmVjdGl2ZS5cbiAgICovXG4gIF9sb2FkRGVwZW5kZW5jaWVzKHBhdGg6IHN0cmluZywgaW5saW5lTG9hZGVyPzogSW5saW5lTG9hZGVyKTogT2JzZXJ2YWJsZTxUcmFuc2xhdGlvbiB8IFRyYW5zbGF0aW9uW10+IHtcbiAgICBjb25zdCBtYWluTGFuZyA9IGdldExhbmdGcm9tU2NvcGUocGF0aCk7XG5cbiAgICBpZiAodGhpcy5faXNMYW5nU2NvcGVkKHBhdGgpICYmICF0aGlzLmlzTG9hZGVkVHJhbnNsYXRpb24obWFpbkxhbmcpKSB7XG4gICAgICByZXR1cm4gY29tYmluZUxhdGVzdCh0aGlzLmxvYWQobWFpbkxhbmcpLCB0aGlzLmxvYWQocGF0aCwgeyBpbmxpbmVMb2FkZXIgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5sb2FkKHBhdGgsIHsgaW5saW5lTG9hZGVyIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2NvbXBsZXRlU2NvcGVXaXRoTGFuZyhsYW5nT3JTY29wZTogc3RyaW5nKSB7XG4gICAgaWYgKHRoaXMuX2lzTGFuZ1Njb3BlZChsYW5nT3JTY29wZSkgJiYgIXRoaXMuaXNMYW5nKGdldExhbmdGcm9tU2NvcGUobGFuZ09yU2NvcGUpKSkge1xuICAgICAgcmV0dXJuIGAke2xhbmdPclNjb3BlfS8ke3RoaXMuZ2V0QWN0aXZlTGFuZygpfWA7XG4gICAgfVxuICAgIHJldHVybiBsYW5nT3JTY29wZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9zZXRTY29wZUFsaWFzKHNjb3BlOiBzdHJpbmcsIGFsaWFzOiBzdHJpbmcpIHtcbiAgICBpZiAoIXRoaXMubWVyZ2VkQ29uZmlnLnNjb3BlTWFwcGluZykge1xuICAgICAgdGhpcy5tZXJnZWRDb25maWcuc2NvcGVNYXBwaW5nID0ge307XG4gICAgfVxuICAgIHRoaXMubWVyZ2VkQ29uZmlnLnNjb3BlTWFwcGluZ1tzY29wZV0gPSBhbGlhcztcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbikge1xuICAgICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgIC8vIENhcmV0YWtlciBub3RlOiBpdCdzIGltcG9ydGFudCB0byBjbGVhbiB1cCByZWZlcmVuY2VzIHRvIHN1YnNjcmlwdGlvbnMgc2luY2UgdGhleSBzYXZlIHRoZSBgbmV4dGBcbiAgICAgIC8vIGNhbGxiYWNrIHdpdGhpbiBpdHMgYGRlc3RpbmF0aW9uYCBwcm9wZXJ0eSwgcHJldmVudGluZyBjbGFzc2VzIGZyb20gYmVpbmcgR0MnZC5cbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICB9XG4gICAgLy8gQ2FyZXRha2VyIG5vdGU6IHNpbmNlIHRoaXMgaXMgdGhlIHJvb3QgcHJvdmlkZXIsIGl0J2xsIGJlIGRlc3Ryb3llZCB3aGVuIHRoZSBgTmdNb2R1bGVSZWYuZGVzdHJveSgpYCBpcyBydW4uXG4gICAgLy8gQ2FjaGVkIHZhbHVlcyBjYXB0dXJlIGB0aGlzYCwgdGh1cyBsZWFkaW5nIHRvIGEgY2lyY3VsYXIgcmVmZXJlbmNlIGFuZCBwcmV2ZW50aW5nIHRoZSBgVHJhbnNsb2NvU2VydmljZWAgZnJvbVxuICAgIC8vIGJlaW5nIEdDJ2QuIFRoaXMgd291bGQgbGVhZCB0byBhIG1lbW9yeSBsZWFrIHdoZW4gc2VydmVyLXNpZGUgcmVuZGVyaW5nIGlzIHVzZWQgc2luY2UgdGhlIHNlcnZpY2UgaXMgY3JlYXRlZFxuICAgIC8vIGFuZCBkZXN0cm95ZWQgcGVyIGVhY2ggSFRUUCByZXF1ZXN0LCBidXQgYW55IHNlcnZpY2UgaXMgbm90IGdldHRpbmcgR0MnZC5cbiAgICB0aGlzLmNhY2hlLmNsZWFyKCk7XG4gIH1cblxuICBwcml2YXRlIGlzTG9hZGVkVHJhbnNsYXRpb24obGFuZzogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHNpemUodGhpcy5nZXRUcmFuc2xhdGlvbihsYW5nKSk7XG4gIH1cblxuICBwcml2YXRlIGdldEF2YWlsYWJsZUxhbmdzSWRzKCk6IHN0cmluZ1tdIHtcbiAgICBjb25zdCBmaXJzdCA9IHRoaXMuZ2V0QXZhaWxhYmxlTGFuZ3MoKVswXTtcblxuICAgIGlmIChpc1N0cmluZyhmaXJzdCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEF2YWlsYWJsZUxhbmdzKCkgYXMgc3RyaW5nW107XG4gICAgfVxuXG4gICAgcmV0dXJuICh0aGlzLmdldEF2YWlsYWJsZUxhbmdzKCkgYXMgeyBpZDogc3RyaW5nIH1bXSkubWFwKGwgPT4gbC5pZCk7XG4gIH1cblxuICBwcml2YXRlIGdldE1pc3NpbmdIYW5kbGVyRGF0YSgpOiBUcmFuc2xvY29NaXNzaW5nSGFuZGxlckRhdGEge1xuICAgIHJldHVybiB7XG4gICAgICAuLi50aGlzLmNvbmZpZyxcbiAgICAgIGFjdGl2ZUxhbmc6IHRoaXMuZ2V0QWN0aXZlTGFuZygpLFxuICAgICAgYXZhaWxhYmxlTGFuZ3M6IHRoaXMuYXZhaWxhYmxlTGFuZ3MsXG4gICAgICBkZWZhdWx0TGFuZzogdGhpcy5kZWZhdWx0TGFuZ1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVXNlIGEgZmFsbGJhY2sgdHJhbnNsYXRpb24gc2V0IGZvciBtaXNzaW5nIGtleXMgb2YgdGhlIHByaW1hcnkgbGFuZ3VhZ2VcbiAgICogVGhpcyBpcyB1bnJlbGF0ZWQgdG8gdGhlIGZhbGxiYWNrIGxhbmd1YWdlICh3aGljaCBjaGFuZ2VzIHRoZSBhY3RpdmUgbGFuZ3VhZ2UpXG4gICAqL1xuICBwcml2YXRlIHVzZUZhbGxiYWNrVHJhbnNsYXRpb24obGFuZz86IHN0cmluZykge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5taXNzaW5nSGFuZGxlci51c2VGYWxsYmFja1RyYW5zbGF0aW9uICYmIGxhbmcgIT09IHRoaXMuZmlyc3RGYWxsYmFja0xhbmc7XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZVN1Y2Nlc3MobGFuZzogc3RyaW5nLCB0cmFuc2xhdGlvbjogVHJhbnNsYXRpb24pIHtcbiAgICB0aGlzLnNldFRyYW5zbGF0aW9uKHRyYW5zbGF0aW9uLCBsYW5nLCB7IGVtaXRDaGFuZ2U6IGZhbHNlIH0pO1xuICAgIHRoaXMuZXZlbnRzLm5leHQoe1xuICAgICAgd2FzRmFpbHVyZTogISF0aGlzLmZhaWxlZExhbmdzLnNpemUsXG4gICAgICB0eXBlOiAndHJhbnNsYXRpb25Mb2FkU3VjY2VzcycsXG4gICAgICBwYXlsb2FkOiBnZXRFdmVudFBheWxvYWQobGFuZylcbiAgICB9KTtcbiAgICB0aGlzLmZhaWxlZExhbmdzLmZvckVhY2gobCA9PiB0aGlzLmNhY2hlLmRlbGV0ZShsKSk7XG4gICAgdGhpcy5mYWlsZWRMYW5ncy5jbGVhcigpO1xuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVGYWlsdXJlKGxhbmc6IHN0cmluZywgbG9hZE9wdGlvbnM6IExvYWRPcHRpb25zKSB7XG4gICAgLy8gV2hlbiBzdGFydGluZyB0byBsb2FkIGEgZmlyc3QgY2hvaWNlIGxhbmd1YWdlLCBpbml0aWFsaXplXG4gICAgLy8gdGhlIGZhaWxlZCBjb3VudGVyIGFuZCByZXNvbHZlIHRoZSBmYWxsYmFjayBsYW5ncy5cbiAgICBpZiAoaXNOaWwobG9hZE9wdGlvbnMuZmFpbGVkQ291bnRlcikpIHtcbiAgICAgIGxvYWRPcHRpb25zLmZhaWxlZENvdW50ZXIgPSAwO1xuXG4gICAgICBpZiAoIWxvYWRPcHRpb25zLmZhbGxiYWNrTGFuZ3MpIHtcbiAgICAgICAgbG9hZE9wdGlvbnMuZmFsbGJhY2tMYW5ncyA9IHRoaXMuZmFsbGJhY2tTdHJhdGVneS5nZXROZXh0TGFuZ3MobGFuZyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc3BsaXR0ZWQgPSBsYW5nLnNwbGl0KCcvJyk7XG4gICAgY29uc3QgZmFsbGJhY2tzID0gbG9hZE9wdGlvbnMuZmFsbGJhY2tMYW5ncztcbiAgICBjb25zdCBuZXh0TGFuZyA9IGZhbGxiYWNrc1tsb2FkT3B0aW9ucy5mYWlsZWRDb3VudGVyXTtcbiAgICB0aGlzLmZhaWxlZExhbmdzLmFkZChsYW5nKTtcblxuICAgIC8vIFRoaXMgaGFuZGxlcyB0aGUgY2FzZSB3aGVyZSBhIGxvYWRlZCBmYWxsYmFjayBsYW5ndWFnZSBpcyByZXF1ZXN0ZWQgYWdhaW5cbiAgICBpZiAodGhpcy5jYWNoZS5oYXMobmV4dExhbmcpKSB7XG4gICAgICB0aGlzLmhhbmRsZVN1Y2Nlc3MobmV4dExhbmcsIHRoaXMuZ2V0VHJhbnNsYXRpb24obmV4dExhbmcpKTtcbiAgICAgIHJldHVybiBFTVBUWTtcbiAgICB9XG5cbiAgICBjb25zdCBpc0ZhbGxiYWNrTGFuZyA9IG5leHRMYW5nID09PSBzcGxpdHRlZFtzcGxpdHRlZC5sZW5ndGggLSAxXTtcblxuICAgIGlmICghbmV4dExhbmcgfHwgaXNGYWxsYmFja0xhbmcpIHtcbiAgICAgIGxldCBtc2cgPSBgVW5hYmxlIHRvIGxvYWQgdHJhbnNsYXRpb24gYW5kIGFsbCB0aGUgZmFsbGJhY2sgbGFuZ3VhZ2VzYDtcbiAgICAgIGlmIChzcGxpdHRlZC5sZW5ndGggPiAxKSB7XG4gICAgICAgIG1zZyArPSBgLCBkaWQgeW91IG1pc3NwZWxsZWQgdGhlIHNjb3BlIG5hbWU/YDtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxuXG4gICAgbGV0IHJlc29sdmVMYW5nID0gbmV4dExhbmc7XG4gICAgLy8gaWYgaXQncyBzY29wZWQgbGFuZ1xuICAgIGlmIChzcGxpdHRlZC5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIHJlc29sdmUgaXQgdG86XG4gICAgICAvLyB0b2Rvcy9sYW5nTm90RXhpc3RzID0+IHRvZG9zL25leHRMYW5nXG4gICAgICBzcGxpdHRlZFtzcGxpdHRlZC5sZW5ndGggLSAxXSA9IG5leHRMYW5nO1xuICAgICAgcmVzb2x2ZUxhbmcgPSBzcGxpdHRlZC5qb2luKCcvJyk7XG4gICAgfVxuXG4gICAgbG9hZE9wdGlvbnMuZmFpbGVkQ291bnRlcisrO1xuICAgIHRoaXMuZXZlbnRzLm5leHQoe1xuICAgICAgdHlwZTogJ3RyYW5zbGF0aW9uTG9hZEZhaWx1cmUnLFxuICAgICAgcGF5bG9hZDogZ2V0RXZlbnRQYXlsb2FkKGxhbmcpXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5sb2FkKHJlc29sdmVMYW5nLCBsb2FkT3B0aW9ucyk7XG4gIH1cblxuICBwcml2YXRlIGdldE1hcHBlZFNjb3BlKHNjb3BlOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IHsgc2NvcGVNYXBwaW5nID0ge30gfSA9IHRoaXMuY29uZmlnO1xuICAgIHJldHVybiBzY29wZU1hcHBpbmdbc2NvcGVdIHx8IHRvQ2FtZWxDYXNlKHNjb3BlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiBsYW5nIGlzIHNjb3BlIHdlIG5lZWQgdG8gY2hlY2sgdGhlIGZvbGxvd2luZyBjYXNlczpcbiAgICogdG9kb3MvZXMgPT4gaW4gdGhpcyBjYXNlIHdlIHNob3VsZCB0YWtlIGBlc2AgYXMgbGFuZ1xuICAgKiB0b2RvcyA9PiBpbiB0aGlzIGNhc2Ugd2Ugc2hvdWxkIHNldCB0aGUgYWN0aXZlIGxhbmcgYXMgbGFuZ1xuICAgKi9cbiAgcHJpdmF0ZSByZXNvbHZlTGFuZ0FuZFNjb3BlKGxhbmc6IHN0cmluZykge1xuICAgIGxldCByZXNvbHZlTGFuZyA9IGxhbmc7XG4gICAgbGV0IHNjb3BlO1xuXG4gICAgaWYgKHRoaXMuX2lzTGFuZ1Njb3BlZChsYW5nKSkge1xuICAgICAgLy8gZW4gZm9yIGV4YW1wbGVcbiAgICAgIGNvbnN0IGxhbmdGcm9tU2NvcGUgPSBnZXRMYW5nRnJvbVNjb3BlKGxhbmcpO1xuICAgICAgLy8gZW4gaXMgbGFuZ1xuICAgICAgY29uc3QgaGFzTGFuZyA9IHRoaXMuaXNMYW5nKGxhbmdGcm9tU2NvcGUpO1xuICAgICAgLy8gdGFrZSBlblxuICAgICAgcmVzb2x2ZUxhbmcgPSBoYXNMYW5nID8gbGFuZ0Zyb21TY29wZSA6IHRoaXMuZ2V0QWN0aXZlTGFuZygpO1xuICAgICAgLy8gZmluZCB0aGUgc2NvcGVcbiAgICAgIHNjb3BlID0gdGhpcy5nZXRNYXBwZWRTY29wZShoYXNMYW5nID8gZ2V0U2NvcGVGcm9tTGFuZyhsYW5nKSA6IGxhbmcpO1xuICAgIH1cbiAgICByZXR1cm4geyBzY29wZSwgcmVzb2x2ZUxhbmcgfTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0T2JqZWN0QnlLZXkodHJhbnNsYXRpb246IFRyYW5zbGF0aW9uLCBrZXk6IHN0cmluZykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGNvbnN0IHByZWZpeCA9IGAke2tleX0uYDtcblxuICAgIGZvciAoY29uc3QgY3VycmVudEtleSBpbiB0cmFuc2xhdGlvbikge1xuICAgICAgaWYgKGN1cnJlbnRLZXkuc3RhcnRzV2l0aChwcmVmaXgpKSB7XG4gICAgICAgIHJlc3VsdFtjdXJyZW50S2V5LnJlcGxhY2UocHJlZml4LCAnJyldID0gdHJhbnNsYXRpb25bY3VycmVudEtleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0RW50cmllcyhrZXk6IEhhc2hNYXAgfCBNYXA8c3RyaW5nLCBIYXNoTWFwPikge1xuICAgIHJldHVybiBrZXkgaW5zdGFuY2VvZiBNYXAgPyBrZXkuZW50cmllcygpIDogT2JqZWN0LmVudHJpZXMoa2V5KTtcbiAgfVxufVxuIl19