/**
 * @fileoverview added by tsickle
 * Generated from: lib/transloco.pipe.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ChangeDetectorRef, Inject, Optional, Pipe } from '@angular/core';
import { TranslocoService } from './transloco.service';
import { switchMap } from 'rxjs/operators';
import { forkJoin } from 'rxjs';
import { TRANSLOCO_SCOPE } from './transloco-scope';
import { TRANSLOCO_LANG } from './transloco-lang';
import { listenOrNotOperator, resolveInlineLoader, shouldListenToLangChanges } from './shared';
import { LangResolver } from './lang-resolver';
import { ScopeResolver } from './scope-resolver';
export class TranslocoPipe {
    /**
     * @param {?} translocoService
     * @param {?} providerScope
     * @param {?} providerLang
     * @param {?} cdr
     */
    constructor(translocoService, providerScope, providerLang, cdr) {
        this.translocoService = translocoService;
        this.providerScope = providerScope;
        this.providerLang = providerLang;
        this.cdr = cdr;
        this.subscription = null;
        this.lastValue = '';
        this.langResolver = new LangResolver();
        this.scopeResolver = new ScopeResolver(this.translocoService);
    }
    // null is for handling strict mode + async pipe types https://github.com/ngneat/transloco/issues/311
    // null is for handling strict mode + optional chaining types https://github.com/ngneat/transloco/issues/488
    /**
     * @param {?} key
     * @param {?=} params
     * @param {?=} inlineLang
     * @return {?}
     */
    transform(key, params, inlineLang) {
        if (!key) {
            return key;
        }
        /** @type {?} */
        const keyName = params ? `${key}${JSON.stringify(params)}` : key;
        if (keyName === this.lastKey) {
            return this.lastValue;
        }
        this.lastKey = keyName;
        this.subscription && this.subscription.unsubscribe();
        /** @type {?} */
        const listenToLangChange = shouldListenToLangChanges(this.translocoService, this.providerLang || inlineLang);
        this.subscription = this.translocoService.langChanges$
            .pipe(switchMap((/**
         * @param {?} activeLang
         * @return {?}
         */
        activeLang => {
            /** @type {?} */
            const lang = this.langResolver.resolve({
                inline: inlineLang,
                provider: this.providerLang,
                active: activeLang
            });
            return Array.isArray(this.providerScope)
                ? forkJoin(((/** @type {?} */ (this.providerScope))).map((/**
                 * @param {?} providerScope
                 * @return {?}
                 */
                providerScope => this.resolveScope(lang, providerScope))))
                : this.resolveScope(lang, this.providerScope);
        })), listenOrNotOperator(listenToLangChange))
            .subscribe((/**
         * @return {?}
         */
        () => this.updateValue(key, params)));
        return this.lastValue;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
            // Caretaker note: it's important to clean up references to subscriptions since they save the `next`
            // callback within its `destination` property, preventing classes from being GC'd.
            this.subscription = null;
        }
    }
    /**
     * @private
     * @param {?} key
     * @param {?=} params
     * @return {?}
     */
    updateValue(key, params) {
        /** @type {?} */
        const lang = this.langResolver.resolveLangBasedOnScope(this.path);
        this.lastValue = this.translocoService.translate(key, params, lang);
        this.cdr.markForCheck();
    }
    /**
     * @private
     * @param {?} lang
     * @param {?} providerScope
     * @return {?}
     */
    resolveScope(lang, providerScope) {
        /** @type {?} */
        let resolvedScope = this.scopeResolver.resolve({ inline: undefined, provider: providerScope });
        this.path = this.langResolver.resolveLangPath(lang, resolvedScope);
        /** @type {?} */
        const inlineLoader = resolveInlineLoader(providerScope, resolvedScope);
        return this.translocoService._loadDependencies(this.path, inlineLoader);
    }
}
TranslocoPipe.decorators = [
    { type: Pipe, args: [{
                name: 'transloco',
                pure: false
            },] }
];
/** @nocollapse */
TranslocoPipe.ctorParameters = () => [
    { type: TranslocoService },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [TRANSLOCO_SCOPE,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [TRANSLOCO_LANG,] }] },
    { type: ChangeDetectorRef }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    TranslocoPipe.prototype.subscription;
    /**
     * @type {?}
     * @private
     */
    TranslocoPipe.prototype.lastValue;
    /**
     * @type {?}
     * @private
     */
    TranslocoPipe.prototype.lastKey;
    /**
     * @type {?}
     * @private
     */
    TranslocoPipe.prototype.path;
    /**
     * @type {?}
     * @private
     */
    TranslocoPipe.prototype.langResolver;
    /**
     * @type {?}
     * @private
     */
    TranslocoPipe.prototype.scopeResolver;
    /**
     * @type {?}
     * @private
     */
    TranslocoPipe.prototype.translocoService;
    /**
     * @type {?}
     * @private
     */
    TranslocoPipe.prototype.providerScope;
    /**
     * @type {?}
     * @private
     */
    TranslocoPipe.prototype.providerLang;
    /**
     * @type {?}
     * @private
     */
    TranslocoPipe.prototype.cdr;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNsb2NvLnBpcGUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AbmduZWF0L3RyYW5zbG9jby8iLCJzb3VyY2VzIjpbImxpYi90cmFuc2xvY28ucGlwZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLEVBQWEsUUFBUSxFQUFFLElBQUksRUFBaUIsTUFBTSxlQUFlLENBQUM7QUFDcEcsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFFdkQsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzNDLE9BQU8sRUFBRSxRQUFRLEVBQTRCLE1BQU0sTUFBTSxDQUFDO0FBQzFELE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUNwRCxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDbEQsT0FBTyxFQUFFLG1CQUFtQixFQUFFLG1CQUFtQixFQUFFLHlCQUF5QixFQUFFLE1BQU0sVUFBVSxDQUFDO0FBQy9GLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMvQyxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFNakQsTUFBTSxPQUFPLGFBQWE7Ozs7Ozs7SUFReEIsWUFDVSxnQkFBa0MsRUFDRyxhQUF5QyxFQUMxQyxZQUEyQixFQUMvRCxHQUFzQjtRQUh0QixxQkFBZ0IsR0FBaEIsZ0JBQWdCLENBQWtCO1FBQ0csa0JBQWEsR0FBYixhQUFhLENBQTRCO1FBQzFDLGlCQUFZLEdBQVosWUFBWSxDQUFlO1FBQy9ELFFBQUcsR0FBSCxHQUFHLENBQW1CO1FBWHhCLGlCQUFZLEdBQXdCLElBQUksQ0FBQztRQUN6QyxjQUFTLEdBQVcsRUFBRSxDQUFDO1FBR3ZCLGlCQUFZLEdBQUcsSUFBSSxZQUFZLEVBQUUsQ0FBQztRQUNsQyxrQkFBYSxHQUFHLElBQUksYUFBYSxDQUFD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QWEsQ0FBQyxDQUFDOztjQUM3RCxZQUFZLEdBQUcsbUJBQW1CLENBQUMsYUFBYSxFQUFFLGFBQWEsQ0FBQztRQUN0RSxPQUFPLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLFlBQVksQ0FBQyxDQUFDO0lBQzFFLENBQUM7OztZQS9FRixJQUFJLFNBQUM7Z0JBQ0osSUFBSSxFQUFFLFdBQVc7Z0JBQ2pCLElBQUksRUFBRSxLQUFLO2FBQ1o7Ozs7WUFiUSxnQkFBZ0I7NENBd0JwQixRQUFRLFlBQUksTUFBTSxTQUFDLGVBQWU7NENBQ2xDLFFBQVEsWUFBSSxNQUFNLFNBQUMsY0FBYztZQTFCN0IsaUJBQWlCOzs7Ozs7O0lBZ0J4QixxQ0FBaUQ7Ozs7O0lBQ2pELGtDQUErQjs7Ozs7SUFDL0IsZ0NBQW9DOzs7OztJQUNwQyw2QkFBcUI7Ozs7O0lBQ3JCLHFDQUEwQzs7Ozs7SUFDMUMsc0NBQWlFOzs7OztJQUcvRCx5Q0FBMEM7Ozs7O0lBQzFDLHNDQUFzRjs7Ozs7SUFDdEYscUNBQXVFOzs7OztJQUN2RSw0QkFBOEIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDaGFuZ2VEZXRlY3RvclJlZiwgSW5qZWN0LCBPbkRlc3Ryb3ksIE9wdGlvbmFsLCBQaXBlLCBQaXBlVHJhbnNmb3JtIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBUcmFuc2xvY29TZXJ2aWNlIH0gZnJvbSAnLi90cmFuc2xvY28uc2VydmljZSc7XG5pbXBvcnQgeyBIYXNoTWFwLCBNYXliZUFycmF5LCBUcmFuc2xhdGlvbiwgVHJhbnNsb2NvU2NvcGUgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IHN3aXRjaE1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IGZvcmtKb2luLCBPYnNlcnZhYmxlLCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFRSQU5TTE9DT19TQ09QRSB9IGZyb20gJy4vdHJhbnNsb2NvLXNjb3BlJztcbmltcG9ydCB7IFRSQU5TTE9DT19MQU5HIH0gZnJvbSAnLi90cmFuc2xvY28tbGFuZyc7XG5pbXBvcnQgeyBsaXN0ZW5Pck5vdE9wZXJhdG9yLCByZXNvbHZlSW5saW5lTG9hZGVyLCBzaG91bGRMaXN0ZW5Ub0xhbmdDaGFuZ2VzIH0gZnJvbSAnLi9zaGFyZWQnO1xuaW1wb3J0IHsgTGFuZ1Jlc29sdmVyIH0gZnJvbSAnLi9sYW5nLXJlc29sdmVyJztcbmltcG9ydCB7IFNjb3BlUmVzb2x2ZXIgfSBmcm9tICcuL3Njb3BlLXJlc29sdmVyJztcblxuQFBpcGUoe1xuICBuYW1lOiAndHJhbnNsb2NvJyxcbiAgcHVyZTogZmFsc2Vcbn0pXG5leHBvcnQgY2xhc3MgVHJhbnNsb2NvUGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0sIE9uRGVzdHJveSB7XG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb24gfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBsYXN0VmFsdWU6IHN0cmluZyA9ICcnO1xuICBwcml2YXRlIGxhc3RLZXk6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgcHJpdmF0ZSBwYXRoOiBzdHJpbmc7XG4gIHByaXZhdGUgbGFuZ1Jlc29sdmVyID0gbmV3IExhbmdSZXNvbHZlcigpO1xuICBwcml2YXRlIHNjb3BlUmVzb2x2ZXIgPSBuZXcgU2NvcGVSZXNvbHZlcih0aGlzLnRyYW5zbG9jb1NlcnZpY2UpO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgdHJhbnNsb2NvU2VydmljZTogVHJhbnNsb2NvU2VydmljZSxcbiAgICBAT3B0aW9uYWwoKSBASW5qZWN0KFRSQU5TTE9DT19TQ09QRSkgcHJpdmF0ZSBwcm92aWRlclNjb3BlOiBNYXliZUFycmF5PFRyYW5zbG9jb1Njb3BlPixcbiAgICBAT3B0aW9uYWwoKSBASW5qZWN0KFRSQU5TTE9DT19MQU5HKSBwcml2YXRlIHByb3ZpZGVyTGFuZzogc3RyaW5nIHwgbnVsbCxcbiAgICBwcml2YXRlIGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWZcbiAgKSB7fVxuXG4gIC8vIG51bGwgaXMgZm9yIGhhbmRsaW5nIHN0cmljdCBtb2RlICsgYXN5bmMgcGlwZSB0eXBlcyBodHRwczovL2dpdGh1Yi5jb20vbmduZWF0L3RyYW5zbG9jby9pc3N1ZXMvMzExXG4gIC8vIG51bGwgaXMgZm9yIGhhbmRsaW5nIHN0cmljdCBtb2RlICsgb3B0aW9uYWwgY2hhaW5pbmcgdHlwZXMgaHR0cHM6Ly9naXRodWIuY29tL25nbmVhdC90cmFuc2xvY28vaXNzdWVzLzQ4OFxuICB0cmFuc2Zvcm0oa2V5OiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkLCBwYXJhbXM/OiBIYXNoTWFwIHwgdW5kZWZpbmVkLCBpbmxpbmVMYW5nPzogc3RyaW5nIHwgdW5kZWZpbmVkKTogc3RyaW5nIHtcbiAgICBpZiAoIWtleSkge1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG5cbiAgICBjb25zdCBrZXlOYW1lID0gcGFyYW1zID8gYCR7a2V5fSR7SlNPTi5zdHJpbmdpZnkocGFyYW1zKX1gIDoga2V5O1xuXG4gICAgaWYgKGtleU5hbWUgPT09IHRoaXMubGFzdEtleSkge1xuICAgICAgcmV0dXJuIHRoaXMubGFzdFZhbHVlO1xuICAgIH1cblxuICAgIHRoaXMubGFzdEtleSA9IGtleU5hbWU7XG4gICAgdGhpcy5zdWJzY3JpcHRpb24gJiYgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcblxuICAgIGNvbnN0IGxpc3RlblRvTGFuZ0NoYW5nZSA9IHNob3VsZExpc3RlblRvTGFuZ0NoYW5nZXModGhpcy50cmFuc2xvY29TZXJ2aWNlLCB0aGlzLnByb3ZpZGVyTGFuZyB8fCBpbmxpbmVMYW5nKTtcblxuICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gdGhpcy50cmFuc2xvY29TZXJ2aWNlLmxhbmdDaGFuZ2VzJFxuICAgICAgLnBpcGUoXG4gICAgICAgIHN3aXRjaE1hcChhY3RpdmVMYW5nID0+IHtcbiAgICAgICAgICBjb25zdCBsYW5nID0gdGhpcy5sYW5nUmVzb2x2ZXIucmVzb2x2ZSh7XG4gICAgICAgICAgICBpbmxpbmU6IGlubGluZUxhbmcsXG4gICAgICAgICAgICBwcm92aWRlcjogdGhpcy5wcm92aWRlckxhbmcsXG4gICAgICAgICAgICBhY3RpdmU6IGFjdGl2ZUxhbmdcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHRoaXMucHJvdmlkZXJTY29wZSlcbiAgICAgICAgICAgID8gZm9ya0pvaW4oXG4gICAgICAgICAgICAgICAgKDxUcmFuc2xvY29TY29wZVtdPnRoaXMucHJvdmlkZXJTY29wZSkubWFwKHByb3ZpZGVyU2NvcGUgPT4gdGhpcy5yZXNvbHZlU2NvcGUobGFuZywgcHJvdmlkZXJTY29wZSkpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIDogdGhpcy5yZXNvbHZlU2NvcGUobGFuZywgdGhpcy5wcm92aWRlclNjb3BlKTtcbiAgICAgICAgfSksXG4gICAgICAgIGxpc3Rlbk9yTm90T3BlcmF0b3IobGlzdGVuVG9MYW5nQ2hhbmdlKVxuICAgICAgKVxuICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLnVwZGF0ZVZhbHVlKGtleSwgcGFyYW1zKSk7XG5cbiAgICByZXR1cm4gdGhpcy5sYXN0VmFsdWU7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5zdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAvLyBDYXJldGFrZXIgbm90ZTogaXQncyBpbXBvcnRhbnQgdG8gY2xlYW4gdXAgcmVmZXJlbmNlcyB0byBzdWJzY3JpcHRpb25zIHNpbmNlIHRoZXkgc2F2ZSB0aGUgYG5leHRgXG4gICAgICAvLyBjYWxsYmFjayB3aXRoaW4gaXRzIGBkZXN0aW5hdGlvbmAgcHJvcGVydHksIHByZXZlbnRpbmcgY2xhc3NlcyBmcm9tIGJlaW5nIEdDJ2QuXG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVWYWx1ZShrZXk6IHN0cmluZywgcGFyYW1zPzogSGFzaE1hcCB8IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IGxhbmcgPSB0aGlzLmxhbmdSZXNvbHZlci5yZXNvbHZlTGFuZ0Jhc2VkT25TY29wZSh0aGlzLnBhdGgpO1xuICAgIHRoaXMubGFzdFZhbHVlID0gdGhpcy50cmFuc2xvY29TZXJ2aWNlLnRyYW5zbGF0ZShrZXksIHBhcmFtcywgbGFuZyk7XG4gICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gIH1cblxuICBwcml2YXRlIHJlc29sdmVTY29wZShsYW5nOiBzdHJpbmcsIHByb3ZpZGVyU2NvcGU6IFRyYW5zbG9jb1Njb3BlKTogT2JzZXJ2YWJsZTxUcmFuc2xhdGlvbiB8IFRyYW5zbGF0aW9uW10+IHtcbiAgICBsZXQgcmVzb2x2ZWRTY29wZSA9IHRoaXMuc2NvcGVSZXNvbHZlci5yZXNvbHZlKHsgaW5saW5lOiB1bmRlZmluZWQsIHByb3ZpZGVyOiBwcm92aWRlclNjb3BlIH0pO1xuICAgIHRoaXMucGF0aCA9IHRoaXMubGFuZ1Jlc29sdmVyLnJlc29sdmVMYW5nUGF0aChsYW5nLCByZXNvbHZlZFNjb3BlKTtcbiAgICBjb25zdCBpbmxpbmVMb2FkZXIgPSByZXNvbHZlSW5saW5lTG9hZGVyKHByb3ZpZGVyU2NvcGUsIHJlc29sdmVkU2NvcGUpO1xuICAgIHJldHVybiB0aGlzLnRyYW5zbG9jb1NlcnZpY2UuX2xvYWREZXBlbmRlbmNpZXModGhpcy5wYXRoLCBpbmxpbmVMb2FkZXIpO1xuICB9XG59XG4iXX0=