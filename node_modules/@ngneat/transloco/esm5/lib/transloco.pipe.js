/**
 * @fileoverview added by tsickle
 * Generated from: lib/transloco.pipe.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ChangeDetectorRef, Inject, Optional, Pipe } from '@angular/core';
import { TranslocoService } from './transloco.service';
import { switchMap } from 'rxjs/operators';
import { forkJoin } from 'rxjs';
import { TRANSLOCO_SCOPE } from './transloco-scope';
import { TRANSLOCO_LANG } from './transloco-lang';
import { listenOrNotOperator, resolveInlineLoader, shouldListenToLangChanges } from './shared';
import { LangResolver } from './lang-resolver';
import { ScopeResolver } from './scope-resolver';
var TranslocoPipe = /** @class */ (function () {
    function TranslocoPipe(translocoService, providerScope, providerLang, cdr) {
        this.translocoService = translocoService;
        this.providerScope = providerScope;
        this.providerLang = providerLang;
        this.cdr = cdr;
        this.subscription = null;
        this.lastValue = '';
        this.langResolver = new LangResolver();
        this.scopeResolver = new ScopeResolver(this.translocoService);
    }
    // null is for handling strict mode + async pipe types https://github.com/ngneat/transloco/issues/311
    // null is for handling strict mode + optional chaining types https://github.com/ngneat/transloco/issues/488
    // null is for handling strict mode + async pipe types https://github.com/ngneat/transloco/issues/311
    // null is for handling strict mode + optional chaining types https://github.com/ngneat/transloco/issues/488
    /**
     * @param {?} key
     * @param {?=} params
     * @param {?=} inlineLang
     * @return {?}
     */
    TranslocoPipe.prototype.transform = 
    // null is for handling strict mode + async pipe types https://github.com/ngneat/transloco/issues/311
    // null is for handling strict mode + optional chaining types https://github.com/ngneat/transloco/issues/488
    /**
     * @param {?} key
     * @param {?=} params
     * @param {?=} inlineLang
     * @return {?}
     */
    function (key, params, inlineLang) {
        var _this = this;
        if (!key) {
            return key;
        }
        /** @type {?} */
        var keyName = params ? "" + key + JSON.stringify(params) : key;
        if (keyName === this.lastKey) {
            return this.lastValue;
        }
        this.lastKey = keyName;
        this.subscription && this.subscription.unsubscribe();
        /** @type {?} */
        var listenToLangChange = shouldListenToLangChanges(this.translocoService, this.providerLang || inlineLang);
        this.subscription = this.translocoService.langChanges$
            .pipe(switchMap((/**
         * @param {?} activeLang
         * @return {?}
         */
        function (activeLang) {
            /** @type {?} */
            var lang = _this.langResolver.resolve({
                inline: inlineLang,
                provider: _this.providerLang,
                active: activeLang
            });
            return Array.isArray(_this.providerScope)
                ? forkJoin(((/** @type {?} */ (_this.providerScope))).map((/**
                 * @param {?} providerScope
                 * @return {?}
                 */
                function (providerScope) { return _this.resolveScope(lang, providerScope); })))
                : _this.resolveScope(lang, _this.providerScope);
        })), listenOrNotOperator(listenToLangChange))
            .subscribe((/**
         * @return {?}
         */
        function () { return _this.updateValue(key, params); }));
        return this.lastValue;
    };
    /**
     * @return {?}
     */
    TranslocoPipe.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.subscription) {
            this.subscription.unsubscribe();
            // Caretaker note: it's important to clean up references to subscriptions since they save the `next`
            // callback within its `destination` property, preventing classes from being GC'd.
            this.subscription = null;
        }
    };
    /**
     * @private
     * @param {?} key
     * @param {?=} params
     * @return {?}
     */
    TranslocoPipe.prototype.updateValue = /**
     * @private
     * @param {?} key
     * @param {?=} params
     * @return {?}
     */
    function (key, params) {
        /** @type {?} */
        var lang = this.langResolver.resolveLangBasedOnScope(this.path);
        this.lastValue = this.translocoService.translate(key, params, lang);
        this.cdr.markForCheck();
    };
    /**
     * @private
     * @param {?} lang
     * @param {?} providerScope
     * @return {?}
     */
    TranslocoPipe.prototype.resolveScope = /**
     * @private
     * @param {?} lang
     * @param {?} providerScope
     * @return {?}
     */
    function (lang, providerScope) {
        /** @type {?} */
        var resolvedScope = this.scopeResolver.resolve({ inline: undefined, provider: providerScope });
        this.path = this.langResolver.resolveLangPath(lang, resolvedScope);
        /** @type {?} */
        var inlineLoader = resolveInlineLoader(providerScope, resolvedScope);
        return this.translocoService._loadDependencies(this.path, inlineLoader);
    };
    TranslocoPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'transloco',
                    pure: false
                },] }
    ];
    /** @nocollapse */
    TranslocoPipe.ctorParameters = function () { return [
        { type: TranslocoService },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [TRANSLOCO_SCOPE,] }] },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [TRANSLOCO_LANG,] }] },
        { type: ChangeDetectorRef }
    ]; };
    return TranslocoPipe;
}());
export { TranslocoPipe };
if (false) {
    /**
     * @type {?}
     * @private
     */
    TranslocoPipe.prototype.subscription;
    /**
     * @type {?}
     * @private
     */
    TranslocoPipe.prototype.lastValue;
    /**
     * @type {?}
     * @private
     */
    TranslocoPipe.prototype.lastKey;
    /**
     * @type {?}
     * @private
     */
    TranslocoPipe.prototype.path;
    /**
     * @type {?}
     * @private
     */
    TranslocoPipe.prototype.langResolver;
    /**
     * @type {?}
     * @private
     */
    TranslocoPipe.prototype.scopeResolver;
    /**
     * @type {?}
     * @private
     */
    TranslocoPipe.prototype.translocoService;
    /**
     * @type {?}
     * @private
     */
    TranslocoPipe.prototype.providerScope;
    /**
     * @type {?}
     * @private
     */
    TranslocoPipe.prototype.providerLang;
    /**
     * @type {?}
     * @private
     */
    TranslocoPipe.prototype.cdr;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNsb2NvLnBpcGUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AbmduZWF0L3RyYW5zbG9jby8iLCJzb3VyY2VzIjpbImxpYi90cmFuc2xvY28ucGlwZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLEVBQWEsUUFBUSxFQUFFLElBQUksRUFBaUIsTUFBTSxlQUFlLENBQUM7QUFDcEcsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFFdkQsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzNDLE9BQU8sRUFBRSxRQUFRLEVBQTRCLE1BQU0sTUFBTSxDQUFDO0FBQzFELE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUNwRCxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDbEQsT0FBTyxFQUFFLG1CQUFtQixFQUFFLG1CQUFtQixFQUFFLHlCQUF5QixFQUFFLE1BQU0sVUFBVSxDQUFDO0FBQy9GLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMvQyxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFFakQ7SUFZRSx1QkFDVSxnQkFBa0MsRUFDRyxhQUF5QyxFQUMxQyxZQUEyQixFQUMvRCxHQUFzQjtRQUh0QixxQkFBZ0IsR0FBaEIsZ0JBQWdCLENBQWtCO1FBQ0csa0JBQWEsR0FBYixhQUFhLENBQTRCO1FBQzFDLGlCQUFZLEdBQVosWUFBWSxDQUFlO1FBQy9ELFFBQUcsR0FBSCxHQUFHLENBQW1CO1FBWHhCLGlCQUFZLEdBQXdCLElBQUksQ0FBQztRQUN6QyxjQUFTLEdBQVcsRUFBRSxDQUFDO1FBR3ZCLGlCQUFZLEdBQUcsSUFBSSxZQUFZLEVBQUUsQ0FBQztRQUNsQyxrQkFBYSxHQUFHLElBQUksYUFBYSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FB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RSxDQUFDO1FBQzlGLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxlQUFlLENBQUMsSUFBSSxFQUFFLGFBQWEsQ0FBQyxDQUFDOztZQUM3RCxZQUFZLEdBQUcsbUJBQW1CLENBQUMsYUFBYSxFQUFFLGFBQWEsQ0FBQztRQUN0RSxPQUFPLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLFlBQVksQ0FBQyxDQUFDO0lBQzFFLENBQUM7O2dCQS9FRixJQUFJLFNBQUM7b0JBQ0osSUFBSSxFQUFFLFdBQVc7b0JBQ2pCLElBQUksRUFBRSxLQUFLO2lCQUNaOzs7O2dCQWJRLGdCQUFnQjtnREF3QnBCLFFBQVEsWUFBSSxNQUFNLFNBQUMsZUFBZTtnREFDbEMsUUFBUSxZQUFJLE1BQU0sU0FBQyxjQUFjO2dCQTFCN0IsaUJBQWlCOztJQTJGMUIsb0JBQUM7Q0FBQSxBQWhGRCxJQWdGQztTQTVFWSxhQUFhOzs7Ozs7SUFDeEIscUNBQWlEOzs7OztJQUNqRCxrQ0FBK0I7Ozs7O0lBQy9CLGdDQUFvQzs7Ozs7SUFDcEMsNkJBQXFCOzs7OztJQUNyQixxQ0FBMEM7Ozs7O0lBQzFDLHNDQUFpRTs7Ozs7SUFHL0QseUNBQTBDOzs7OztJQUMxQyxzQ0FBc0Y7Ozs7O0lBQ3RGLHFDQUF1RTs7Ozs7SUFDdkUsNEJBQThCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0b3JSZWYsIEluamVjdCwgT25EZXN0cm95LCBPcHRpb25hbCwgUGlwZSwgUGlwZVRyYW5zZm9ybSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVHJhbnNsb2NvU2VydmljZSB9IGZyb20gJy4vdHJhbnNsb2NvLnNlcnZpY2UnO1xuaW1wb3J0IHsgSGFzaE1hcCwgTWF5YmVBcnJheSwgVHJhbnNsYXRpb24sIFRyYW5zbG9jb1Njb3BlIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBzd2l0Y2hNYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBmb3JrSm9pbiwgT2JzZXJ2YWJsZSwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBUUkFOU0xPQ09fU0NPUEUgfSBmcm9tICcuL3RyYW5zbG9jby1zY29wZSc7XG5pbXBvcnQgeyBUUkFOU0xPQ09fTEFORyB9IGZyb20gJy4vdHJhbnNsb2NvLWxhbmcnO1xuaW1wb3J0IHsgbGlzdGVuT3JOb3RPcGVyYXRvciwgcmVzb2x2ZUlubGluZUxvYWRlciwgc2hvdWxkTGlzdGVuVG9MYW5nQ2hhbmdlcyB9IGZyb20gJy4vc2hhcmVkJztcbmltcG9ydCB7IExhbmdSZXNvbHZlciB9IGZyb20gJy4vbGFuZy1yZXNvbHZlcic7XG5pbXBvcnQgeyBTY29wZVJlc29sdmVyIH0gZnJvbSAnLi9zY29wZS1yZXNvbHZlcic7XG5cbkBQaXBlKHtcbiAgbmFtZTogJ3RyYW5zbG9jbycsXG4gIHB1cmU6IGZhbHNlXG59KVxuZXhwb3J0IGNsYXNzIFRyYW5zbG9jb1BpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtLCBPbkRlc3Ryb3kge1xuICBwcml2YXRlIHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgbGFzdFZhbHVlOiBzdHJpbmcgPSAnJztcbiAgcHJpdmF0ZSBsYXN0S2V5OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIHByaXZhdGUgcGF0aDogc3RyaW5nO1xuICBwcml2YXRlIGxhbmdSZXNvbHZlciA9IG5ldyBMYW5nUmVzb2x2ZXIoKTtcbiAgcHJpdmF0ZSBzY29wZVJlc29sdmVyID0gbmV3IFNjb3BlUmVzb2x2ZXIodGhpcy50cmFuc2xvY29TZXJ2aWNlKTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHRyYW5zbG9jb1NlcnZpY2U6IFRyYW5zbG9jb1NlcnZpY2UsXG4gICAgQE9wdGlvbmFsKCkgQEluamVjdChUUkFOU0xPQ09fU0NPUEUpIHByaXZhdGUgcHJvdmlkZXJTY29wZTogTWF5YmVBcnJheTxUcmFuc2xvY29TY29wZT4sXG4gICAgQE9wdGlvbmFsKCkgQEluamVjdChUUkFOU0xPQ09fTEFORykgcHJpdmF0ZSBwcm92aWRlckxhbmc6IHN0cmluZyB8IG51bGwsXG4gICAgcHJpdmF0ZSBjZHI6IENoYW5nZURldGVjdG9yUmVmXG4gICkge31cblxuICAvLyBudWxsIGlzIGZvciBoYW5kbGluZyBzdHJpY3QgbW9kZSArIGFzeW5jIHBpcGUgdHlwZXMgaHR0cHM6Ly9naXRodWIuY29tL25nbmVhdC90cmFuc2xvY28vaXNzdWVzLzMxMVxuICAvLyBudWxsIGlzIGZvciBoYW5kbGluZyBzdHJpY3QgbW9kZSArIG9wdGlvbmFsIGNoYWluaW5nIHR5cGVzIGh0dHBzOi8vZ2l0aHViLmNvbS9uZ25lYXQvdHJhbnNsb2NvL2lzc3Vlcy80ODhcbiAgdHJhbnNmb3JtKGtleTogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZCwgcGFyYW1zPzogSGFzaE1hcCB8IHVuZGVmaW5lZCwgaW5saW5lTGFuZz86IHN0cmluZyB8IHVuZGVmaW5lZCk6IHN0cmluZyB7XG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuXG4gICAgY29uc3Qga2V5TmFtZSA9IHBhcmFtcyA/IGAke2tleX0ke0pTT04uc3RyaW5naWZ5KHBhcmFtcyl9YCA6IGtleTtcblxuICAgIGlmIChrZXlOYW1lID09PSB0aGlzLmxhc3RLZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLmxhc3RWYWx1ZTtcbiAgICB9XG5cbiAgICB0aGlzLmxhc3RLZXkgPSBrZXlOYW1lO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9uICYmIHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG5cbiAgICBjb25zdCBsaXN0ZW5Ub0xhbmdDaGFuZ2UgPSBzaG91bGRMaXN0ZW5Ub0xhbmdDaGFuZ2VzKHRoaXMudHJhbnNsb2NvU2VydmljZSwgdGhpcy5wcm92aWRlckxhbmcgfHwgaW5saW5lTGFuZyk7XG5cbiAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IHRoaXMudHJhbnNsb2NvU2VydmljZS5sYW5nQ2hhbmdlcyRcbiAgICAgIC5waXBlKFxuICAgICAgICBzd2l0Y2hNYXAoYWN0aXZlTGFuZyA9PiB7XG4gICAgICAgICAgY29uc3QgbGFuZyA9IHRoaXMubGFuZ1Jlc29sdmVyLnJlc29sdmUoe1xuICAgICAgICAgICAgaW5saW5lOiBpbmxpbmVMYW5nLFxuICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXMucHJvdmlkZXJMYW5nLFxuICAgICAgICAgICAgYWN0aXZlOiBhY3RpdmVMYW5nXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0aGlzLnByb3ZpZGVyU2NvcGUpXG4gICAgICAgICAgICA/IGZvcmtKb2luKFxuICAgICAgICAgICAgICAgICg8VHJhbnNsb2NvU2NvcGVbXT50aGlzLnByb3ZpZGVyU2NvcGUpLm1hcChwcm92aWRlclNjb3BlID0+IHRoaXMucmVzb2x2ZVNjb3BlKGxhbmcsIHByb3ZpZGVyU2NvcGUpKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICA6IHRoaXMucmVzb2x2ZVNjb3BlKGxhbmcsIHRoaXMucHJvdmlkZXJTY29wZSk7XG4gICAgICAgIH0pLFxuICAgICAgICBsaXN0ZW5Pck5vdE9wZXJhdG9yKGxpc3RlblRvTGFuZ0NoYW5nZSlcbiAgICAgIClcbiAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy51cGRhdGVWYWx1ZShrZXksIHBhcmFtcykpO1xuXG4gICAgcmV0dXJuIHRoaXMubGFzdFZhbHVlO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgLy8gQ2FyZXRha2VyIG5vdGU6IGl0J3MgaW1wb3J0YW50IHRvIGNsZWFuIHVwIHJlZmVyZW5jZXMgdG8gc3Vic2NyaXB0aW9ucyBzaW5jZSB0aGV5IHNhdmUgdGhlIGBuZXh0YFxuICAgICAgLy8gY2FsbGJhY2sgd2l0aGluIGl0cyBgZGVzdGluYXRpb25gIHByb3BlcnR5LCBwcmV2ZW50aW5nIGNsYXNzZXMgZnJvbSBiZWluZyBHQydkLlxuICAgICAgdGhpcy5zdWJzY3JpcHRpb24gPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlVmFsdWUoa2V5OiBzdHJpbmcsIHBhcmFtcz86IEhhc2hNYXAgfCB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBsYW5nID0gdGhpcy5sYW5nUmVzb2x2ZXIucmVzb2x2ZUxhbmdCYXNlZE9uU2NvcGUodGhpcy5wYXRoKTtcbiAgICB0aGlzLmxhc3RWYWx1ZSA9IHRoaXMudHJhbnNsb2NvU2VydmljZS50cmFuc2xhdGUoa2V5LCBwYXJhbXMsIGxhbmcpO1xuICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuICB9XG5cbiAgcHJpdmF0ZSByZXNvbHZlU2NvcGUobGFuZzogc3RyaW5nLCBwcm92aWRlclNjb3BlOiBUcmFuc2xvY29TY29wZSk6IE9ic2VydmFibGU8VHJhbnNsYXRpb24gfCBUcmFuc2xhdGlvbltdPiB7XG4gICAgbGV0IHJlc29sdmVkU2NvcGUgPSB0aGlzLnNjb3BlUmVzb2x2ZXIucmVzb2x2ZSh7IGlubGluZTogdW5kZWZpbmVkLCBwcm92aWRlcjogcHJvdmlkZXJTY29wZSB9KTtcbiAgICB0aGlzLnBhdGggPSB0aGlzLmxhbmdSZXNvbHZlci5yZXNvbHZlTGFuZ1BhdGgobGFuZywgcmVzb2x2ZWRTY29wZSk7XG4gICAgY29uc3QgaW5saW5lTG9hZGVyID0gcmVzb2x2ZUlubGluZUxvYWRlcihwcm92aWRlclNjb3BlLCByZXNvbHZlZFNjb3BlKTtcbiAgICByZXR1cm4gdGhpcy50cmFuc2xvY29TZXJ2aWNlLl9sb2FkRGVwZW5kZW5jaWVzKHRoaXMucGF0aCwgaW5saW5lTG9hZGVyKTtcbiAgfVxufVxuIl19