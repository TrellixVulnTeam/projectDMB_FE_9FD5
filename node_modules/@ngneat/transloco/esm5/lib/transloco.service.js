/**
 * @fileoverview added by tsickle
 * Generated from: lib/transloco.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Inject, Injectable, Optional } from '@angular/core';
import { BehaviorSubject, combineLatest, EMPTY, forkJoin, from, of, Subject } from 'rxjs';
import { catchError, map, retry, shareReplay, switchMap, tap } from 'rxjs/operators';
import { DefaultLoader, TRANSLOCO_LOADER } from './transloco.loader';
import { TRANSLOCO_TRANSPILER } from './transloco.transpiler';
import { flatten, isEmpty, isNil, isScopeObject, isString, size, toCamelCase, unflatten } from './helpers';
import { defaultConfig, TRANSLOCO_CONFIG } from './transloco.config';
import { TRANSLOCO_MISSING_HANDLER } from './transloco-missing-handler';
import { TRANSLOCO_INTERCEPTOR } from './transloco.interceptor';
import { TRANSLOCO_FALLBACK_STRATEGY } from './transloco-fallback-strategy';
import { mergeConfig } from './merge-config';
import { getEventPayload, getLangFromScope, getScopeFromLang, resolveInlineLoader } from './shared';
import { getFallbacksLoaders } from './get-fallbacks-loaders';
import { resolveLoader } from './resolve-loader';
import * as i0 from "@angular/core";
import * as i1 from "./transloco.loader";
import * as i2 from "./transloco.transpiler";
import * as i3 from "./transloco-missing-handler";
import * as i4 from "./transloco.interceptor";
import * as i5 from "./transloco.config";
import * as i6 from "./transloco-fallback-strategy";
/** @type {?} */
var service;
/**
 * @template T
 * @param {?} key
 * @param {?=} params
 * @param {?=} lang
 * @return {?}
 */
export function translate(key, params, lang) {
    if (params === void 0) { params = {}; }
    return service.translate(key, params, lang);
}
var TranslocoService = /** @class */ (function () {
    function TranslocoService(loader, parser, missingHandler, interceptor, userConfig, fallbackStrategy) {
        var _this = this;
        this.loader = loader;
        this.parser = parser;
        this.missingHandler = missingHandler;
        this.interceptor = interceptor;
        this.userConfig = userConfig;
        this.fallbackStrategy = fallbackStrategy;
        this.subscription = null;
        this.translations = new Map();
        this.cache = new Map();
        this.firstFallbackLang = null;
        this.availableLangs = [];
        this.isResolvedMissingOnce = false;
        this.events = new Subject();
        this.events$ = this.events.asObservable();
        this.failedLangs = new Set();
        if (!this.loader) {
            this.loader = new DefaultLoader(this.translations);
        }
        service = this;
        this.mergedConfig = mergeConfig(defaultConfig, userConfig);
        this.setAvailableLangs(this.mergedConfig.availableLangs);
        this.setFallbackLangForMissingTranslation(this.mergedConfig);
        this.setDefaultLang(this.mergedConfig.defaultLang);
        this.lang = new BehaviorSubject(this.getDefaultLang());
        // Don't use distinctUntilChanged as we need the ability to update
        // the value when using setTranslation or setTranslationKeys
        this.langChanges$ = this.lang.asObservable();
        /**
         * When we have a failure, we want to define the next language that succeeded as the active
         */
        this.subscription = this.events$.subscribe((/**
         * @param {?} e
         * @return {?}
         */
        function (e) {
            if (e.type === 'translationLoadSuccess' && e.wasFailure) {
                // Handle scoped lang
                /** @type {?} */
                var lang = getLangFromScope(e.payload.lang);
                _this.setActiveLang(lang);
            }
        }));
    }
    Object.defineProperty(TranslocoService.prototype, "config", {
        get: /**
         * @return {?}
         */
        function () {
            return this.mergedConfig;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    TranslocoService.prototype.getDefaultLang = /**
     * @return {?}
     */
    function () {
        return this.defaultLang;
    };
    /**
     * @param {?} lang
     * @return {?}
     */
    TranslocoService.prototype.setDefaultLang = /**
     * @param {?} lang
     * @return {?}
     */
    function (lang) {
        this.defaultLang = lang;
    };
    /**
     * @return {?}
     */
    TranslocoService.prototype.getActiveLang = /**
     * @return {?}
     */
    function () {
        return this.lang.getValue();
    };
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} lang
     * @return {THIS}
     */
    TranslocoService.prototype.setActiveLang = /**
     * @template THIS
     * @this {THIS}
     * @param {?} lang
     * @return {THIS}
     */
    function (lang) {
        (/** @type {?} */ (this)).parser.onLangChanged && (/** @type {?} */ (this)).parser.onLangChanged(lang);
        (/** @type {?} */ (this)).lang.next(lang);
        return (/** @type {?} */ (this));
    };
    /**
     * @param {?} langs
     * @return {?}
     */
    TranslocoService.prototype.setAvailableLangs = /**
     * @param {?} langs
     * @return {?}
     */
    function (langs) {
        this.availableLangs = langs;
    };
    /**
     * Gets the available languages.
     *
     * @returns
     * An array of the available languages. Can be either a `string[]` or a `{ id: string; label: string }[]`
     * depending on how the available languages are set in your module.
     */
    /**
     * Gets the available languages.
     *
     * @return {?}
     * An array of the available languages. Can be either a `string[]` or a `{ id: string; label: string }[]`
     * depending on how the available languages are set in your module.
     */
    TranslocoService.prototype.getAvailableLangs = /**
     * Gets the available languages.
     *
     * @return {?}
     * An array of the available languages. Can be either a `string[]` or a `{ id: string; label: string }[]`
     * depending on how the available languages are set in your module.
     */
    function () {
        return this.availableLangs;
    };
    /**
     * @param {?} path
     * @param {?=} options
     * @return {?}
     */
    TranslocoService.prototype.load = /**
     * @param {?} path
     * @param {?=} options
     * @return {?}
     */
    function (path, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        if (this.cache.has(path) === false) {
            /** @type {?} */
            var loadTranslation = void 0;
            /** @type {?} */
            var isScope = this._isLangScoped(path);
            /** @type {?} */
            var scope = isScope ? getScopeFromLang(path) : null;
            if (this.useFallbackTranslation(path)) {
                // if the path is scope the fallback should be `scope/fallbackLang`;
                /** @type {?} */
                var fallback = isScope ? scope + "/" + this.firstFallbackLang : this.firstFallbackLang;
                /** @type {?} */
                var loaders = getFallbacksLoaders(path, fallback, this.loader, options.inlineLoader, { scope: scope });
                loadTranslation = forkJoin(loaders);
            }
            else {
                /** @type {?} */
                var loader = resolveLoader(path, this.loader, options.inlineLoader, { scope: scope });
                loadTranslation = from(loader);
            }
            /** @type {?} */
            var load$ = loadTranslation.pipe(retry(this.config.failedRetries), tap((/**
             * @param {?} translation
             * @return {?}
             */
            function (translation) {
                if (Array.isArray(translation)) {
                    translation.forEach((/**
                     * @param {?} t
                     * @return {?}
                     */
                    function (t) {
                        _this.handleSuccess(t.lang, t.translation);
                        // Save the fallback in cache so we'll not create a redundant request
                        if (t.lang !== path) {
                            _this.cache.set(t.lang, of({}));
                        }
                    }));
                    return;
                }
                _this.handleSuccess(path, translation);
            })), catchError((/**
             * @param {?} error
             * @return {?}
             */
            function (error) {
                if (!_this.mergedConfig.prodMode) {
                    console.error("Error while trying to load \"" + path + "\"", error);
                }
                return _this.handleFailure(path, options);
            })), shareReplay(1));
            this.cache.set(path, load$);
        }
        return this.cache.get(path);
    };
    /**
     * Gets the instant translated value of a key
     *
     * @example
     *
     * translate<string>('hello')
     * translate('hello', { value: 'value' })
     * translate<string[]>(['hello', 'key'])
     * translate('hello', { }, 'en')
     * translate('scope.someKey', { }, 'en')
     */
    /**
     * Gets the instant translated value of a key
     *
     * \@example
     *
     * translate<string>('hello')
     * translate('hello', { value: 'value' })
     * translate<string[]>(['hello', 'key'])
     * translate('hello', { }, 'en')
     * translate('scope.someKey', { }, 'en')
     * @template T
     * @param {?} key
     * @param {?=} params
     * @param {?=} lang
     * @return {?}
     */
    TranslocoService.prototype.translate = /**
     * Gets the instant translated value of a key
     *
     * \@example
     *
     * translate<string>('hello')
     * translate('hello', { value: 'value' })
     * translate<string[]>(['hello', 'key'])
     * translate('hello', { }, 'en')
     * translate('scope.someKey', { }, 'en')
     * @template T
     * @param {?} key
     * @param {?=} params
     * @param {?=} lang
     * @return {?}
     */
    function (key, params, lang) {
        var _this = this;
        if (params === void 0) { params = {}; }
        if (lang === void 0) { lang = this.getActiveLang(); }
        if (!key)
            return (/** @type {?} */ (key));
        var _a = this.resolveLangAndScope(lang), scope = _a.scope, resolveLang = _a.resolveLang;
        if (Array.isArray(key)) {
            return (/** @type {?} */ (key.map((/**
             * @param {?} k
             * @return {?}
             */
            function (k) { return _this.translate(scope ? scope + "." + k : k, params, resolveLang); }))));
        }
        key = scope ? scope + "." + key : key;
        /** @type {?} */
        var translation = this.getTranslation(resolveLang);
        /** @type {?} */
        var value = translation[key];
        if (!value) {
            return this._handleMissingKey(key, value, params);
        }
        return this.parser.transpile(value, params, translation);
    };
    /**
     * Gets the translated value of a key as observable
     *
     * @example
     *
     * selectTranslate<string>('hello').subscribe(value => ...)
     * selectTranslate<string>('hello', {}, 'es').subscribe(value => ...)
     * selectTranslate<string>('hello', {}, 'todos').subscribe(value => ...)
     * selectTranslate<string>('hello', {}, { scope: 'todos' }).subscribe(value => ...)
     *
     */
    /**
     * Gets the translated value of a key as observable
     *
     * \@example
     *
     * selectTranslate<string>('hello').subscribe(value => ...)
     * selectTranslate<string>('hello', {}, 'es').subscribe(value => ...)
     * selectTranslate<string>('hello', {}, 'todos').subscribe(value => ...)
     * selectTranslate<string>('hello', {}, { scope: 'todos' }).subscribe(value => ...)
     *
     * @template T
     * @param {?} key
     * @param {?=} params
     * @param {?=} lang
     * @param {?=} _isObject
     * @return {?}
     */
    TranslocoService.prototype.selectTranslate = /**
     * Gets the translated value of a key as observable
     *
     * \@example
     *
     * selectTranslate<string>('hello').subscribe(value => ...)
     * selectTranslate<string>('hello', {}, 'es').subscribe(value => ...)
     * selectTranslate<string>('hello', {}, 'todos').subscribe(value => ...)
     * selectTranslate<string>('hello', {}, { scope: 'todos' }).subscribe(value => ...)
     *
     * @template T
     * @param {?} key
     * @param {?=} params
     * @param {?=} lang
     * @param {?=} _isObject
     * @return {?}
     */
    function (key, params, lang, _isObject) {
        var _this = this;
        if (_isObject === void 0) { _isObject = false; }
        /** @type {?} */
        var inlineLoader = null;
        /** @type {?} */
        var load = (/**
         * @param {?} lang
         * @param {?=} options
         * @return {?}
         */
        function (lang, options) {
            return _this.load(lang, options).pipe(map((/**
             * @return {?}
             */
            function () { return (_isObject ? _this.translateObject(key, params, lang) : _this.translate(key, params, lang)); })));
        });
        if (isNil(lang)) {
            return this.langChanges$.pipe(switchMap((/**
             * @param {?} lang
             * @return {?}
             */
            function (lang) { return load(lang); })));
        }
        if (isScopeObject(lang)) {
            // it's a scope object.
            /** @type {?} */
            var providerScope = (/** @type {?} */ (lang));
            lang = providerScope.scope;
            inlineLoader = resolveInlineLoader(providerScope, providerScope.scope);
        }
        lang = (/** @type {?} */ (lang));
        if (this.isLang(lang) || this.isScopeWithLang(lang)) {
            return load(lang);
        }
        // it's a scope
        /** @type {?} */
        var scope = lang;
        return this.langChanges$.pipe(switchMap((/**
         * @param {?} lang
         * @return {?}
         */
        function (lang) { return load(scope + "/" + lang, { inlineLoader: inlineLoader }); })));
    };
    /**
     * Whether the scope with lang
     *
     * @example
     *
     * todos/en => true
     * todos => false
     */
    /**
     * Whether the scope with lang
     *
     * \@example
     *
     * todos/en => true
     * todos => false
     * @private
     * @param {?} lang
     * @return {?}
     */
    TranslocoService.prototype.isScopeWithLang = /**
     * Whether the scope with lang
     *
     * \@example
     *
     * todos/en => true
     * todos => false
     * @private
     * @param {?} lang
     * @return {?}
     */
    function (lang) {
        return this.isLang(getLangFromScope(lang));
    };
    /**
     * @template T
     * @param {?} key
     * @param {?=} params
     * @param {?=} lang
     * @return {?}
     */
    TranslocoService.prototype.translateObject = /**
     * @template T
     * @param {?} key
     * @param {?=} params
     * @param {?=} lang
     * @return {?}
     */
    function (key, params, lang) {
        var _this = this;
        if (lang === void 0) { lang = this.getActiveLang(); }
        var e_1, _a;
        if (isString(key) || Array.isArray(key)) {
            if (Array.isArray(key)) {
                return (/** @type {?} */ (key.map((/**
                 * @param {?} k
                 * @return {?}
                 */
                function (k) { return _this.translateObject(scope_1 ? scope_1 + "." + k : k, params, resolveLang_1); }))));
            }
            var _b = this.resolveLangAndScope(lang), resolveLang_1 = _b.resolveLang, scope_1 = _b.scope;
            /** @type {?} */
            var translation = this.getTranslation(resolveLang_1);
            key = scope_1 ? scope_1 + "." + key : key;
            /** @type {?} */
            var value = unflatten(this.getObjectByKey(translation, key));
            /* If an empty object was returned we want to try and translate the key as a string and not an object */
            return isEmpty(value) ? this.translate(key, params, lang) : this.parser.transpile(value, params, translation);
        }
        /** @type {?} */
        var translations = [];
        try {
            for (var _c = tslib_1.__values(this.getEntries(key)), _d = _c.next(); !_d.done; _d = _c.next()) {
                var _e = tslib_1.__read(_d.value, 2), _key = _e[0], _params = _e[1];
                translations.push(this.translateObject(_key, _params, lang));
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return translations;
    };
    /**
     * @template T
     * @param {?} key
     * @param {?=} params
     * @param {?=} lang
     * @return {?}
     */
    TranslocoService.prototype.selectTranslateObject = /**
     * @template T
     * @param {?} key
     * @param {?=} params
     * @param {?=} lang
     * @return {?}
     */
    function (key, params, lang) {
        var _this = this;
        if (isString(key) || Array.isArray(key)) {
            return this.selectTranslate(key, params, lang, true);
        }
        var _a = tslib_1.__read(this.getEntries(key)), _b = tslib_1.__read(_a[0], 2), firstKey = _b[0], firstParams = _b[1], rest = _a.slice(1);
        /* In order to avoid subscribing multiple times to the load language event by calling selectTranslateObject for each pair,
         * we listen to when the first key has been translated (the language is loaded) and translate the rest synchronously */
        return this.selectTranslateObject(firstKey, firstParams, lang).pipe(map((/**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            var e_2, _a;
            /** @type {?} */
            var translations = [value];
            try {
                for (var rest_1 = tslib_1.__values(rest), rest_1_1 = rest_1.next(); !rest_1_1.done; rest_1_1 = rest_1.next()) {
                    var _b = tslib_1.__read(rest_1_1.value, 2), _key = _b[0], _params = _b[1];
                    translations.push(_this.translateObject(_key, _params, lang));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (rest_1_1 && !rest_1_1.done && (_a = rest_1.return)) _a.call(rest_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return translations;
        })));
    };
    /**
     * @param {?=} langOrScope
     * @return {?}
     */
    TranslocoService.prototype.getTranslation = /**
     * @param {?=} langOrScope
     * @return {?}
     */
    function (langOrScope) {
        if (langOrScope) {
            if (this.isLang(langOrScope)) {
                return this.translations.get(langOrScope) || {};
            }
            else {
                // This is a scope, build the scope value from the translation object
                var _a = this.resolveLangAndScope(langOrScope), scope = _a.scope, resolveLang = _a.resolveLang;
                /** @type {?} */
                var translation = this.translations.get(resolveLang) || {};
                return this.getObjectByKey(translation, scope);
            }
        }
        return this.translations;
    };
    /**
     * Gets an object of translations for a given language
     *
     * @example
     *
     * selectTranslation().subscribe() - will return the current lang translation
     * selectTranslation('es').subscribe()
     * selectTranslation('admin-page').subscribe() - will return the current lang scope translation
     * selectTranslation('admin-page/es').subscribe()
     */
    /**
     * Gets an object of translations for a given language
     *
     * \@example
     *
     * selectTranslation().subscribe() - will return the current lang translation
     * selectTranslation('es').subscribe()
     * selectTranslation('admin-page').subscribe() - will return the current lang scope translation
     * selectTranslation('admin-page/es').subscribe()
     * @param {?=} lang
     * @return {?}
     */
    TranslocoService.prototype.selectTranslation = /**
     * Gets an object of translations for a given language
     *
     * \@example
     *
     * selectTranslation().subscribe() - will return the current lang translation
     * selectTranslation('es').subscribe()
     * selectTranslation('admin-page').subscribe() - will return the current lang scope translation
     * selectTranslation('admin-page/es').subscribe()
     * @param {?=} lang
     * @return {?}
     */
    function (lang) {
        var _this = this;
        /** @type {?} */
        var language$ = this.langChanges$;
        if (lang) {
            /** @type {?} */
            var scopeLangSpecified = getLangFromScope(lang) !== lang;
            if (this.isLang(lang) || scopeLangSpecified) {
                language$ = of(lang);
            }
            else {
                language$ = this.langChanges$.pipe(map((/**
                 * @param {?} currentLang
                 * @return {?}
                 */
                function (currentLang) { return lang + "/" + currentLang; })));
            }
        }
        return language$.pipe(switchMap((/**
         * @param {?} language
         * @return {?}
         */
        function (language) { return _this.load(language).pipe(map((/**
         * @return {?}
         */
        function () { return _this.getTranslation(language); }))); })));
    };
    /**
     * Sets or merge a given translation object to current lang
     *
     * @example
     *
     * setTranslation({ ... })
     * setTranslation({ ... }, 'en')
     * setTranslation({ ... }, 'es', { merge: false } )
     * setTranslation({ ... }, 'todos/en', { merge: false } )
     */
    /**
     * Sets or merge a given translation object to current lang
     *
     * \@example
     *
     * setTranslation({ ... })
     * setTranslation({ ... }, 'en')
     * setTranslation({ ... }, 'es', { merge: false } )
     * setTranslation({ ... }, 'todos/en', { merge: false } )
     * @param {?} translation
     * @param {?=} lang
     * @param {?=} options
     * @return {?}
     */
    TranslocoService.prototype.setTranslation = /**
     * Sets or merge a given translation object to current lang
     *
     * \@example
     *
     * setTranslation({ ... })
     * setTranslation({ ... }, 'en')
     * setTranslation({ ... }, 'es', { merge: false } )
     * setTranslation({ ... }, 'todos/en', { merge: false } )
     * @param {?} translation
     * @param {?=} lang
     * @param {?=} options
     * @return {?}
     */
    function (translation, lang, options) {
        if (lang === void 0) { lang = this.getActiveLang(); }
        if (options === void 0) { options = {}; }
        var _a;
        /** @type {?} */
        var defaults = { merge: true, emitChange: true };
        /** @type {?} */
        var mergedOptions = tslib_1.__assign({}, defaults, options);
        /** @type {?} */
        var scope = getScopeFromLang(lang);
        /**
         * If this isn't a scope we use the whole translation as is
         * otherwise we need to flat the scope and use it
         * @type {?}
         */
        var flattenScopeOrTranslation = translation;
        // Merged the scoped language into the active language
        if (scope) {
            /** @type {?} */
            var key = this.getMappedScope(scope);
            flattenScopeOrTranslation = flatten((_a = {}, _a[key] = translation, _a));
        }
        /** @type {?} */
        var currentLang = scope ? getLangFromScope(lang) : lang;
        /** @type {?} */
        var mergedTranslation = tslib_1.__assign({}, (mergedOptions.merge && this.getTranslation(currentLang)), flattenScopeOrTranslation);
        /** @type {?} */
        var flattenTranslation = this.mergedConfig.flatten.aot ? mergedTranslation : flatten(mergedTranslation);
        /** @type {?} */
        var withHook = this.interceptor.preSaveTranslation(flattenTranslation, currentLang);
        this.translations.set(currentLang, withHook);
        mergedOptions.emitChange && this.setActiveLang(this.getActiveLang());
    };
    /**
     * Sets translation key with given value
     *
     * @example
     *
     * setTranslationKey('key', 'value')
     * setTranslationKey('key.nested', 'value')
     * setTranslationKey('key.nested', 'value', 'en')
     * setTranslationKey('key.nested', 'value', 'en', { emitChange: false } )
     */
    /**
     * Sets translation key with given value
     *
     * \@example
     *
     * setTranslationKey('key', 'value')
     * setTranslationKey('key.nested', 'value')
     * setTranslationKey('key.nested', 'value', 'en')
     * setTranslationKey('key.nested', 'value', 'en', { emitChange: false } )
     * @param {?} key
     * @param {?} value
     * @param {?=} lang
     * @param {?=} options
     * @return {?}
     */
    TranslocoService.prototype.setTranslationKey = /**
     * Sets translation key with given value
     *
     * \@example
     *
     * setTranslationKey('key', 'value')
     * setTranslationKey('key.nested', 'value')
     * setTranslationKey('key.nested', 'value', 'en')
     * setTranslationKey('key.nested', 'value', 'en', { emitChange: false } )
     * @param {?} key
     * @param {?} value
     * @param {?=} lang
     * @param {?=} options
     * @return {?}
     */
    function (key, value, lang, 
    // Todo: Use Omit and merge options and lang to one object in v3
    options) {
        if (lang === void 0) { lang = this.getActiveLang(); }
        if (options === void 0) { options = {}; }
        var _a;
        /** @type {?} */
        var withHook = this.interceptor.preSaveTranslationKey(key, value, lang);
        /** @type {?} */
        var newValue = (_a = {},
            _a[key] = withHook,
            _a);
        this.setTranslation(newValue, lang, tslib_1.__assign({}, options, { merge: true }));
    };
    /**
     * Sets the fallback lang for the currently active language
     * @param fallbackLang
     */
    /**
     * Sets the fallback lang for the currently active language
     * @param {?} __0
     * @return {?}
     */
    TranslocoService.prototype.setFallbackLangForMissingTranslation = /**
     * Sets the fallback lang for the currently active language
     * @param {?} __0
     * @return {?}
     */
    function (_a) {
        var fallbackLang = _a.fallbackLang;
        /** @type {?} */
        var lang = Array.isArray(fallbackLang) ? fallbackLang[0] : fallbackLang;
        if (this.useFallbackTranslation(lang) && fallbackLang) {
            this.firstFallbackLang = lang;
        }
    };
    /**
     * @internal
     */
    /**
     * \@internal
     * @param {?} key
     * @param {?} value
     * @param {?=} params
     * @return {?}
     */
    TranslocoService.prototype._handleMissingKey = /**
     * \@internal
     * @param {?} key
     * @param {?} value
     * @param {?=} params
     * @return {?}
     */
    function (key, value, params) {
        if (this.config.missingHandler.allowEmpty && value === '') {
            return '';
        }
        if (this.useFallbackTranslation() && !this.isResolvedMissingOnce) {
            // We need to set it to true to prevent a loop
            this.isResolvedMissingOnce = true;
            /** @type {?} */
            var fallbackValue = this.translate(key, params, this.firstFallbackLang);
            this.isResolvedMissingOnce = false;
            return fallbackValue;
        }
        return this.missingHandler.handle(key, this.getMissingHandlerData(), params);
    };
    /**
     * @internal
     */
    /**
     * \@internal
     * @param {?} lang
     * @return {?}
     */
    TranslocoService.prototype._isLangScoped = /**
     * \@internal
     * @param {?} lang
     * @return {?}
     */
    function (lang) {
        return this.getAvailableLangsIds().indexOf(lang) === -1;
    };
    /**
     * Checks if a given string is one of the specified available languages.
     * @returns
     * True if the given string is an available language.
     * False if the given string is not an available language.
     */
    /**
     * Checks if a given string is one of the specified available languages.
     * @param {?} lang
     * @return {?}
     * True if the given string is an available language.
     * False if the given string is not an available language.
     */
    TranslocoService.prototype.isLang = /**
     * Checks if a given string is one of the specified available languages.
     * @param {?} lang
     * @return {?}
     * True if the given string is an available language.
     * False if the given string is not an available language.
     */
    function (lang) {
        return this.getAvailableLangsIds().indexOf(lang) !== -1;
    };
    /**
     * @internal
     *
     * We always want to make sure the global lang is loaded
     * before loading the scope since you can access both via the pipe/directive.
     */
    /**
     * \@internal
     *
     * We always want to make sure the global lang is loaded
     * before loading the scope since you can access both via the pipe/directive.
     * @param {?} path
     * @param {?=} inlineLoader
     * @return {?}
     */
    TranslocoService.prototype._loadDependencies = /**
     * \@internal
     *
     * We always want to make sure the global lang is loaded
     * before loading the scope since you can access both via the pipe/directive.
     * @param {?} path
     * @param {?=} inlineLoader
     * @return {?}
     */
    function (path, inlineLoader) {
        /** @type {?} */
        var mainLang = getLangFromScope(path);
        if (this._isLangScoped(path) && !this.isLoadedTranslation(mainLang)) {
            return combineLatest(this.load(mainLang), this.load(path, { inlineLoader: inlineLoader }));
        }
        return this.load(path, { inlineLoader: inlineLoader });
    };
    /**
     * @internal
     */
    /**
     * \@internal
     * @param {?} langOrScope
     * @return {?}
     */
    TranslocoService.prototype._completeScopeWithLang = /**
     * \@internal
     * @param {?} langOrScope
     * @return {?}
     */
    function (langOrScope) {
        if (this._isLangScoped(langOrScope) && !this.isLang(getLangFromScope(langOrScope))) {
            return langOrScope + "/" + this.getActiveLang();
        }
        return langOrScope;
    };
    /**
     * @internal
     */
    /**
     * \@internal
     * @param {?} scope
     * @param {?} alias
     * @return {?}
     */
    TranslocoService.prototype._setScopeAlias = /**
     * \@internal
     * @param {?} scope
     * @param {?} alias
     * @return {?}
     */
    function (scope, alias) {
        if (!this.mergedConfig.scopeMapping) {
            this.mergedConfig.scopeMapping = {};
        }
        this.mergedConfig.scopeMapping[scope] = alias;
    };
    /**
     * @return {?}
     */
    TranslocoService.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.subscription) {
            this.subscription.unsubscribe();
            // Caretaker note: it's important to clean up references to subscriptions since they save the `next`
            // callback within its `destination` property, preventing classes from being GC'd.
            this.subscription = null;
        }
        // Caretaker note: since this is the root provider, it'll be destroyed when the `NgModuleRef.destroy()` is run.
        // Cached values capture `this`, thus leading to a circular reference and preventing the `TranslocoService` from
        // being GC'd. This would lead to a memory leak when server-side rendering is used since the service is created
        // and destroyed per each HTTP request, but any service is not getting GC'd.
        this.cache.clear();
    };
    /**
     * @private
     * @param {?} lang
     * @return {?}
     */
    TranslocoService.prototype.isLoadedTranslation = /**
     * @private
     * @param {?} lang
     * @return {?}
     */
    function (lang) {
        return size(this.getTranslation(lang));
    };
    /**
     * @private
     * @return {?}
     */
    TranslocoService.prototype.getAvailableLangsIds = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var first = this.getAvailableLangs()[0];
        if (isString(first)) {
            return (/** @type {?} */ (this.getAvailableLangs()));
        }
        return ((/** @type {?} */ (this.getAvailableLangs()))).map((/**
         * @param {?} l
         * @return {?}
         */
        function (l) { return l.id; }));
    };
    /**
     * @private
     * @return {?}
     */
    TranslocoService.prototype.getMissingHandlerData = /**
     * @private
     * @return {?}
     */
    function () {
        return tslib_1.__assign({}, this.config, { activeLang: this.getActiveLang(), availableLangs: this.availableLangs, defaultLang: this.defaultLang });
    };
    /**
     * Use a fallback translation set for missing keys of the primary language
     * This is unrelated to the fallback language (which changes the active language)
     */
    /**
     * Use a fallback translation set for missing keys of the primary language
     * This is unrelated to the fallback language (which changes the active language)
     * @private
     * @param {?=} lang
     * @return {?}
     */
    TranslocoService.prototype.useFallbackTranslation = /**
     * Use a fallback translation set for missing keys of the primary language
     * This is unrelated to the fallback language (which changes the active language)
     * @private
     * @param {?=} lang
     * @return {?}
     */
    function (lang) {
        return this.config.missingHandler.useFallbackTranslation && lang !== this.firstFallbackLang;
    };
    /**
     * @private
     * @param {?} lang
     * @param {?} translation
     * @return {?}
     */
    TranslocoService.prototype.handleSuccess = /**
     * @private
     * @param {?} lang
     * @param {?} translation
     * @return {?}
     */
    function (lang, translation) {
        var _this = this;
        this.setTranslation(translation, lang, { emitChange: false });
        this.events.next({
            wasFailure: !!this.failedLangs.size,
            type: 'translationLoadSuccess',
            payload: getEventPayload(lang)
        });
        this.failedLangs.forEach((/**
         * @param {?} l
         * @return {?}
         */
        function (l) { return _this.cache.delete(l); }));
        this.failedLangs.clear();
    };
    /**
     * @private
     * @param {?} lang
     * @param {?} loadOptions
     * @return {?}
     */
    TranslocoService.prototype.handleFailure = /**
     * @private
     * @param {?} lang
     * @param {?} loadOptions
     * @return {?}
     */
    function (lang, loadOptions) {
        // When starting to load a first choice language, initialize
        // the failed counter and resolve the fallback langs.
        if (isNil(loadOptions.failedCounter)) {
            loadOptions.failedCounter = 0;
            if (!loadOptions.fallbackLangs) {
                loadOptions.fallbackLangs = this.fallbackStrategy.getNextLangs(lang);
            }
        }
        /** @type {?} */
        var splitted = lang.split('/');
        /** @type {?} */
        var fallbacks = loadOptions.fallbackLangs;
        /** @type {?} */
        var nextLang = fallbacks[loadOptions.failedCounter];
        this.failedLangs.add(lang);
        // This handles the case where a loaded fallback language is requested again
        if (this.cache.has(nextLang)) {
            this.handleSuccess(nextLang, this.getTranslation(nextLang));
            return EMPTY;
        }
        /** @type {?} */
        var isFallbackLang = nextLang === splitted[splitted.length - 1];
        if (!nextLang || isFallbackLang) {
            /** @type {?} */
            var msg = "Unable to load translation and all the fallback languages";
            if (splitted.length > 1) {
                msg += ", did you misspelled the scope name?";
            }
            throw new Error(msg);
        }
        /** @type {?} */
        var resolveLang = nextLang;
        // if it's scoped lang
        if (splitted.length > 1) {
            // We need to resolve it to:
            // todos/langNotExists => todos/nextLang
            splitted[splitted.length - 1] = nextLang;
            resolveLang = splitted.join('/');
        }
        loadOptions.failedCounter++;
        this.events.next({
            type: 'translationLoadFailure',
            payload: getEventPayload(lang)
        });
        return this.load(resolveLang, loadOptions);
    };
    /**
     * @private
     * @param {?} scope
     * @return {?}
     */
    TranslocoService.prototype.getMappedScope = /**
     * @private
     * @param {?} scope
     * @return {?}
     */
    function (scope) {
        var _a = this.config.scopeMapping, scopeMapping = _a === void 0 ? {} : _a;
        return scopeMapping[scope] || toCamelCase(scope);
    };
    /**
     * If lang is scope we need to check the following cases:
     * todos/es => in this case we should take `es` as lang
     * todos => in this case we should set the active lang as lang
     */
    /**
     * If lang is scope we need to check the following cases:
     * todos/es => in this case we should take `es` as lang
     * todos => in this case we should set the active lang as lang
     * @private
     * @param {?} lang
     * @return {?}
     */
    TranslocoService.prototype.resolveLangAndScope = /**
     * If lang is scope we need to check the following cases:
     * todos/es => in this case we should take `es` as lang
     * todos => in this case we should set the active lang as lang
     * @private
     * @param {?} lang
     * @return {?}
     */
    function (lang) {
        /** @type {?} */
        var resolveLang = lang;
        /** @type {?} */
        var scope;
        if (this._isLangScoped(lang)) {
            // en for example
            /** @type {?} */
            var langFromScope = getLangFromScope(lang);
            // en is lang
            /** @type {?} */
            var hasLang = this.isLang(langFromScope);
            // take en
            resolveLang = hasLang ? langFromScope : this.getActiveLang();
            // find the scope
            scope = this.getMappedScope(hasLang ? getScopeFromLang(lang) : lang);
        }
        return { scope: scope, resolveLang: resolveLang };
    };
    /**
     * @private
     * @param {?} translation
     * @param {?} key
     * @return {?}
     */
    TranslocoService.prototype.getObjectByKey = /**
     * @private
     * @param {?} translation
     * @param {?} key
     * @return {?}
     */
    function (translation, key) {
        /** @type {?} */
        var result = {};
        /** @type {?} */
        var prefix = key + ".";
        for (var currentKey in translation) {
            if (currentKey.startsWith(prefix)) {
                result[currentKey.replace(prefix, '')] = translation[currentKey];
            }
        }
        return result;
    };
    /**
     * @private
     * @param {?} key
     * @return {?}
     */
    TranslocoService.prototype.getEntries = /**
     * @private
     * @param {?} key
     * @return {?}
     */
    function (key) {
        return key instanceof Map ? key.entries() : Object.entries(key);
    };
    TranslocoService.decorators = [
        { type: Injectable, args: [{ providedIn: 'root' },] }
    ];
    /** @nocollapse */
    TranslocoService.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [TRANSLOCO_LOADER,] }] },
        { type: undefined, decorators: [{ type: Inject, args: [TRANSLOCO_TRANSPILER,] }] },
        { type: undefined, decorators: [{ type: Inject, args: [TRANSLOCO_MISSING_HANDLER,] }] },
        { type: undefined, decorators: [{ type: Inject, args: [TRANSLOCO_INTERCEPTOR,] }] },
        { type: undefined, decorators: [{ type: Inject, args: [TRANSLOCO_CONFIG,] }] },
        { type: undefined, decorators: [{ type: Inject, args: [TRANSLOCO_FALLBACK_STRATEGY,] }] }
    ]; };
    /** @nocollapse */ TranslocoService.ngInjectableDef = i0.defineInjectable({ factory: function TranslocoService_Factory() { return new TranslocoService(i0.inject(i1.TRANSLOCO_LOADER, 8), i0.inject(i2.TRANSLOCO_TRANSPILER), i0.inject(i3.TRANSLOCO_MISSING_HANDLER), i0.inject(i4.TRANSLOCO_INTERCEPTOR), i0.inject(i5.TRANSLOCO_CONFIG), i0.inject(i6.TRANSLOCO_FALLBACK_STRATEGY)); }, token: TranslocoService, providedIn: "root" });
    return TranslocoService;
}());
export { TranslocoService };
if (false) {
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.subscription;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.translations;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.cache;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.firstFallbackLang;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.defaultLang;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.mergedConfig;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.availableLangs;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.isResolvedMissingOnce;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.lang;
    /** @type {?} */
    TranslocoService.prototype.langChanges$;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.events;
    /** @type {?} */
    TranslocoService.prototype.events$;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.failedLangs;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.loader;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.parser;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.missingHandler;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.interceptor;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.userConfig;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.fallbackStrategy;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNsb2NvLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AbmduZWF0L3RyYW5zbG9jby8iLCJzb3VyY2VzIjpbImxpYi90cmFuc2xvY28uc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxPQUFPLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBYSxRQUFRLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDeEUsT0FBTyxFQUFFLGVBQWUsRUFBRSxhQUFhLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQWMsRUFBRSxFQUFFLE9BQU8sRUFBZ0IsTUFBTSxNQUFNLENBQUM7QUFDcEgsT0FBTyxFQUFFLFVBQVUsRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLFdBQVcsRUFBRSxTQUFTLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDckYsT0FBTyxFQUFFLGFBQWEsRUFBRSxnQkFBZ0IsRUFBbUIsTUFBTSxvQkFBb0IsQ0FBQztBQUN0RixPQUFPLEVBQUUsb0JBQW9CLEVBQXVCLE1BQU0sd0JBQXdCLENBQUM7QUFjbkYsT0FBTyxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLGFBQWEsRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLFdBQVcsRUFBRSxTQUFTLEVBQUUsTUFBTSxXQUFXLENBQUM7QUFDM0csT0FBTyxFQUFFLGFBQWEsRUFBRSxnQkFBZ0IsRUFBbUIsTUFBTSxvQkFBb0IsQ0FBQztBQUN0RixPQUFPLEVBQ0wseUJBQXlCLEVBRzFCLE1BQU0sNkJBQTZCLENBQUM7QUFDckMsT0FBTyxFQUFFLHFCQUFxQixFQUF3QixNQUFNLHlCQUF5QixDQUFDO0FBQ3RGLE9BQU8sRUFBRSwyQkFBMkIsRUFBNkIsTUFBTSwrQkFBK0IsQ0FBQztBQUN2RyxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDN0MsT0FBTyxFQUFFLGVBQWUsRUFBRSxnQkFBZ0IsRUFBRSxnQkFBZ0Is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UUFDcEQsT0FBTyxHQUFHLFlBQVksR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDbEUsQ0FBQzs7Z0JBeG5CRixVQUFVLFNBQUMsRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFOzs7O2dEQW1CN0IsUUFBUSxZQUFJLE1BQU0sU0FBQyxnQkFBZ0I7Z0RBQ25DLE1BQU0sU0FBQyxvQkFBb0I7Z0RBQzNCLE1BQU0sU0FBQyx5QkFBeUI7Z0RBQ2hDLE1BQU0sU0FBQyxxQkFBcUI7Z0RBQzVCLE1BQU0sU0FBQyxnQkFBZ0I7Z0RBQ3ZCLE1BQU0sU0FBQywyQkFBMkI7OzsyQkE5RHZDO0NBK3BCQyxBQXpuQkQsSUF5bkJDO1NBeG5CWSxnQkFBZ0I7Ozs7OztJQUMzQix3Q0FBaUQ7Ozs7O0lBQ2pELHdDQUFzRDs7Ozs7SUFDdEQsaUNBQTJEOzs7OztJQUMzRCw2Q0FBZ0Q7Ozs7O0lBQ2hELHVDQUE0Qjs7Ozs7SUFDNUIsd0NBQXNDOzs7OztJQUN0QywwQ0FBNEM7Ozs7O0lBQzVDLGlEQUFzQzs7Ozs7SUFDdEMsZ0NBQXNDOztJQUN0Qyx3Q0FBaUM7Ozs7O0lBRWpDLGtDQUFnRDs7SUFDaEQsbUNBQXFDOzs7OztJQUVyQyx1Q0FBd0M7Ozs7O0lBR3RDLGtDQUFxRTs7Ozs7SUFDckUsa0NBQWlFOzs7OztJQUNqRSwwQ0FBa0Y7Ozs7O0lBQ2xGLHVDQUF3RTs7Ozs7SUFDeEUsc0NBQTZEOzs7OztJQUM3RCw0Q0FBd0YiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3QsIEluamVjdGFibGUsIE9uRGVzdHJveSwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCwgY29tYmluZUxhdGVzdCwgRU1QVFksIGZvcmtKb2luLCBmcm9tLCBPYnNlcnZhYmxlLCBvZiwgU3ViamVjdCwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBjYXRjaEVycm9yLCBtYXAsIHJldHJ5LCBzaGFyZVJlcGxheSwgc3dpdGNoTWFwLCB0YXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBEZWZhdWx0TG9hZGVyLCBUUkFOU0xPQ09fTE9BREVSLCBUcmFuc2xvY29Mb2FkZXIgfSBmcm9tICcuL3RyYW5zbG9jby5sb2FkZXInO1xuaW1wb3J0IHsgVFJBTlNMT0NPX1RSQU5TUElMRVIsIFRyYW5zbG9jb1RyYW5zcGlsZXIgfSBmcm9tICcuL3RyYW5zbG9jby50cmFuc3BpbGVyJztcbmltcG9ydCB7XG4gIEF2YWlsYWJsZUxhbmdzLFxuICBIYXNoTWFwLFxuICBJbmxpbmVMb2FkZXIsXG4gIExvYWRPcHRpb25zLFxuICBQcm92aWRlclNjb3BlLFxuICBTZXRUcmFuc2xhdGlvbk9wdGlvbnMsXG4gIFRyYW5zbGF0ZU9iamVjdFBhcmFtcyxcbiAgVHJhbnNsYXRlUGFyYW1zLFxuICBUcmFuc2xhdGlvbixcbiAgVHJhbnNsb2NvRXZlbnRzLFxuICBUcmFuc2xvY29TY29wZVxufSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IGZsYXR0ZW4sIGlzRW1wdHksIGlzTmlsLCBpc1Njb3BlT2JqZWN0LCBpc1N0cmluZywgc2l6ZSwgdG9DYW1lbENhc2UsIHVuZmxhdHRlbiB9IGZyb20gJy4vaGVscGVycyc7XG5pbXBvcnQgeyBkZWZhdWx0Q29uZmlnLCBUUkFOU0xPQ09fQ09ORklHLCBUcmFuc2xvY29Db25maWcgfSBmcm9tICcuL3RyYW5zbG9jby5jb25maWcnO1xuaW1wb3J0IHtcbiAgVFJBTlNMT0NPX01JU1NJTkdfSEFORExFUixcbiAgVHJhbnNsb2NvTWlzc2luZ0hhbmRsZXIsXG4gIFRyYW5zbG9jb01pc3NpbmdIYW5kbGVyRGF0YVxufSBmcm9tICcuL3RyYW5zbG9jby1taXNzaW5nLWhhbmRsZXInO1xuaW1wb3J0IHsgVFJBTlNMT0NPX0lOVEVSQ0VQVE9SLCBUcmFuc2xvY29JbnRlcmNlcHRvciB9IGZyb20gJy4vdHJhbnNsb2NvLmludGVyY2VwdG9yJztcbmltcG9ydCB7IFRSQU5TTE9DT19GQUxMQkFDS19TVFJBVEVHWSwgVHJhbnNsb2NvRmFsbGJhY2tTdHJhdGVneSB9IGZyb20gJy4vdHJhbnNsb2NvLWZhbGxiYWNrLXN0cmF0ZWd5JztcbmltcG9ydCB7IG1lcmdlQ29uZmlnIH0gZnJvbSAnLi9tZXJnZS1jb25maWcnO1xuaW1wb3J0IHsgZ2V0RXZlbnRQYXlsb2FkLCBnZXRMYW5nRnJvbVNjb3BlLCBnZXRTY29wZUZyb21MYW5nLCByZXNvbHZlSW5saW5lTG9hZGVyIH0gZnJvbSAnLi9zaGFyZWQnO1xuaW1wb3J0IHsgZ2V0RmFsbGJhY2tzTG9hZGVycyB9IGZyb20gJy4vZ2V0LWZhbGxiYWNrcy1sb2FkZXJzJztcbmltcG9ydCB7IHJlc29sdmVMb2FkZXIgfSBmcm9tICcuL3Jlc29sdmUtbG9hZGVyJztcblxubGV0IHNlcnZpY2U6IFRyYW5zbG9jb1NlcnZpY2U7XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2xhdGU8VCA9IGFueT4oa2V5OiBUcmFuc2xhdGVQYXJhbXMsIHBhcmFtczogSGFzaE1hcCA9IHt9LCBsYW5nPzogc3RyaW5nKTogVCB7XG4gIHJldHVybiBzZXJ2aWNlLnRyYW5zbGF0ZShrZXksIHBhcmFtcywgbGFuZyk7XG59XG5cbkBJbmplY3RhYmxlKHsgcHJvdmlkZWRJbjogJ3Jvb3QnIH0pXG5leHBvcnQgY2xhc3MgVHJhbnNsb2NvU2VydmljZSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb24gfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSB0cmFuc2xhdGlvbnMgPSBuZXcgTWFwPHN0cmluZywgVHJhbnNsYXRpb24+KCk7XG4gIHByaXZhdGUgY2FjaGUgPSBuZXcgTWFwPHN0cmluZywgT2JzZXJ2YWJsZTxUcmFuc2xhdGlvbj4+KCk7XG4gIHByaXZhdGUgZmlyc3RGYWxsYmFja0xhbmc6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGRlZmF1bHRMYW5nOiBzdHJpbmc7XG4gIHByaXZhdGUgbWVyZ2VkQ29uZmlnOiBUcmFuc2xvY29Db25maWc7XG4gIHByaXZhdGUgYXZhaWxhYmxlTGFuZ3M6IEF2YWlsYWJsZUxhbmdzID0gW107XG4gIHByaXZhdGUgaXNSZXNvbHZlZE1pc3NpbmdPbmNlID0gZmFsc2U7XG4gIHByaXZhdGUgbGFuZzogQmVoYXZpb3JTdWJqZWN0PHN0cmluZz47XG4gIGxhbmdDaGFuZ2VzJDogT2JzZXJ2YWJsZTxzdHJpbmc+O1xuXG4gIHByaXZhdGUgZXZlbnRzID0gbmV3IFN1YmplY3Q8VHJhbnNsb2NvRXZlbnRzPigpO1xuICBldmVudHMkID0gdGhpcy5ldmVudHMuYXNPYnNlcnZhYmxlKCk7XG5cbiAgcHJpdmF0ZSBmYWlsZWRMYW5ncyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIEBPcHRpb25hbCgpIEBJbmplY3QoVFJBTlNMT0NPX0xPQURFUikgcHJpdmF0ZSBsb2FkZXI6IFRyYW5zbG9jb0xvYWRlcixcbiAgICBASW5qZWN0KFRSQU5TTE9DT19UUkFOU1BJTEVSKSBwcml2YXRlIHBhcnNlcjogVHJhbnNsb2NvVHJhbnNwaWxlcixcbiAgICBASW5qZWN0KFRSQU5TTE9DT19NSVNTSU5HX0hBTkRMRVIpIHByaXZhdGUgbWlzc2luZ0hhbmRsZXI6IFRyYW5zbG9jb01pc3NpbmdIYW5kbGVyLFxuICAgIEBJbmplY3QoVFJBTlNMT0NPX0lOVEVSQ0VQVE9SKSBwcml2YXRlIGludGVyY2VwdG9yOiBUcmFuc2xvY29JbnRlcmNlcHRvcixcbiAgICBASW5qZWN0KFRSQU5TTE9DT19DT05GSUcpIHByaXZhdGUgdXNlckNvbmZpZzogVHJhbnNsb2NvQ29uZmlnLFxuICAgIEBJbmplY3QoVFJBTlNMT0NPX0ZBTExCQUNLX1NUUkFURUdZKSBwcml2YXRlIGZhbGxiYWNrU3RyYXRlZ3k6IFRyYW5zbG9jb0ZhbGxiYWNrU3RyYXRlZ3lcbiAgKSB7XG4gICAgaWYgKCF0aGlzLmxvYWRlcikge1xuICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgRGVmYXVsdExvYWRlcih0aGlzLnRyYW5zbGF0aW9ucyk7XG4gICAgfVxuICAgIHNlcnZpY2UgPSB0aGlzO1xuICAgIHRoaXMubWVyZ2VkQ29uZmlnID0gbWVyZ2VDb25maWcoZGVmYXVsdENvbmZpZywgdXNlckNvbmZpZyk7XG5cbiAgICB0aGlzLnNldEF2YWlsYWJsZUxhbmdzKHRoaXMubWVyZ2VkQ29uZmlnLmF2YWlsYWJsZUxhbmdzKTtcbiAgICB0aGlzLnNldEZhbGxiYWNrTGFuZ0Zvck1pc3NpbmdUcmFuc2xhdGlvbih0aGlzLm1lcmdlZENvbmZpZyk7XG4gICAgdGhpcy5zZXREZWZhdWx0TGFuZyh0aGlzLm1lcmdlZENvbmZpZy5kZWZhdWx0TGFuZyk7XG4gICAgdGhpcy5sYW5nID0gbmV3IEJlaGF2aW9yU3ViamVjdDxzdHJpbmc+KHRoaXMuZ2V0RGVmYXVsdExhbmcoKSk7XG4gICAgLy8gRG9uJ3QgdXNlIGRpc3RpbmN0VW50aWxDaGFuZ2VkIGFzIHdlIG5lZWQgdGhlIGFiaWxpdHkgdG8gdXBkYXRlXG4gICAgLy8gdGhlIHZhbHVlIHdoZW4gdXNpbmcgc2V0VHJhbnNsYXRpb24gb3Igc2V0VHJhbnNsYXRpb25LZXlzXG4gICAgdGhpcy5sYW5nQ2hhbmdlcyQgPSB0aGlzLmxhbmcuYXNPYnNlcnZhYmxlKCk7XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHdlIGhhdmUgYSBmYWlsdXJlLCB3ZSB3YW50IHRvIGRlZmluZSB0aGUgbmV4dCBsYW5ndWFnZSB0aGF0IHN1Y2NlZWRlZCBhcyB0aGUgYWN0aXZlXG4gICAgICovXG4gICAgdGhpcy5zdWJzY3JpcHRpb24gPSB0aGlzLmV2ZW50cyQuc3Vic2NyaWJlKGUgPT4ge1xuICAgICAgaWYgKGUudHlwZSA9PT0gJ3RyYW5zbGF0aW9uTG9hZFN1Y2Nlc3MnICYmIGUud2FzRmFpbHVyZSkge1xuICAgICAgICAvLyBIYW5kbGUgc2NvcGVkIGxhbmdcbiAgICAgICAgY29uc3QgbGFuZyA9IGdldExhbmdGcm9tU2NvcGUoZS5wYXlsb2FkLmxhbmcpO1xuICAgICAgICB0aGlzLnNldEFjdGl2ZUxhbmcobGFuZyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBnZXQgY29uZmlnKCk6IFRyYW5zbG9jb0NvbmZpZyB7XG4gICAgcmV0dXJuIHRoaXMubWVyZ2VkQ29uZmlnO1xuICB9XG5cbiAgZ2V0RGVmYXVsdExhbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmYXVsdExhbmc7XG4gIH1cblxuICBzZXREZWZhdWx0TGFuZyhsYW5nOiBzdHJpbmcpIHtcbiAgICB0aGlzLmRlZmF1bHRMYW5nID0gbGFuZztcbiAgfVxuXG4gIGdldEFjdGl2ZUxhbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubGFuZy5nZXRWYWx1ZSgpO1xuICB9XG5cbiAgc2V0QWN0aXZlTGFuZyhsYW5nOiBzdHJpbmcpIHtcbiAgICB0aGlzLnBhcnNlci5vbkxhbmdDaGFuZ2VkICYmIHRoaXMucGFyc2VyLm9uTGFuZ0NoYW5nZWQobGFuZyk7XG4gICAgdGhpcy5sYW5nLm5leHQobGFuZyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXRBdmFpbGFibGVMYW5ncyhsYW5nczogQXZhaWxhYmxlTGFuZ3MpIHtcbiAgICB0aGlzLmF2YWlsYWJsZUxhbmdzID0gbGFuZ3M7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgYXZhaWxhYmxlIGxhbmd1YWdlcy5cbiAgICpcbiAgICogQHJldHVybnNcbiAgICogQW4gYXJyYXkgb2YgdGhlIGF2YWlsYWJsZSBsYW5ndWFnZXMuIENhbiBiZSBlaXRoZXIgYSBgc3RyaW5nW11gIG9yIGEgYHsgaWQ6IHN0cmluZzsgbGFiZWw6IHN0cmluZyB9W11gXG4gICAqIGRlcGVuZGluZyBvbiBob3cgdGhlIGF2YWlsYWJsZSBsYW5ndWFnZXMgYXJlIHNldCBpbiB5b3VyIG1vZHVsZS5cbiAgICovXG4gIGdldEF2YWlsYWJsZUxhbmdzKCkge1xuICAgIHJldHVybiB0aGlzLmF2YWlsYWJsZUxhbmdzO1xuICB9XG5cbiAgbG9hZChwYXRoOiBzdHJpbmcsIG9wdGlvbnM6IExvYWRPcHRpb25zID0ge30pOiBPYnNlcnZhYmxlPFRyYW5zbGF0aW9uPiB7XG4gICAgaWYgKHRoaXMuY2FjaGUuaGFzKHBhdGgpID09PSBmYWxzZSkge1xuICAgICAgbGV0IGxvYWRUcmFuc2xhdGlvbjogT2JzZXJ2YWJsZTxUcmFuc2xhdGlvbiB8IHsgdHJhbnNsYXRpb246IFRyYW5zbGF0aW9uOyBsYW5nOiBzdHJpbmcgfVtdPjtcbiAgICAgIGNvbnN0IGlzU2NvcGUgPSB0aGlzLl9pc0xhbmdTY29wZWQocGF0aCk7XG4gICAgICBjb25zdCBzY29wZSA9IGlzU2NvcGUgPyBnZXRTY29wZUZyb21MYW5nKHBhdGgpIDogbnVsbDtcbiAgICAgIGlmICh0aGlzLnVzZUZhbGxiYWNrVHJhbnNsYXRpb24ocGF0aCkpIHtcbiAgICAgICAgLy8gaWYgdGhlIHBhdGggaXMgc2NvcGUgdGhlIGZhbGxiYWNrIHNob3VsZCBiZSBgc2NvcGUvZmFsbGJhY2tMYW5nYDtcbiAgICAgICAgY29uc3QgZmFsbGJhY2sgPSBpc1Njb3BlID8gYCR7c2NvcGV9LyR7dGhpcy5maXJzdEZhbGxiYWNrTGFuZ31gIDogdGhpcy5maXJzdEZhbGxiYWNrTGFuZztcblxuICAgICAgICBjb25zdCBsb2FkZXJzID0gZ2V0RmFsbGJhY2tzTG9hZGVycyhwYXRoLCBmYWxsYmFjaywgdGhpcy5sb2FkZXIsIG9wdGlvbnMuaW5saW5lTG9hZGVyLCB7IHNjb3BlIH0pO1xuICAgICAgICBsb2FkVHJhbnNsYXRpb24gPSBmb3JrSm9pbihsb2FkZXJzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGxvYWRlciA9IHJlc29sdmVMb2FkZXIocGF0aCwgdGhpcy5sb2FkZXIsIG9wdGlvbnMuaW5saW5lTG9hZGVyLCB7IHNjb3BlIH0pO1xuICAgICAgICBsb2FkVHJhbnNsYXRpb24gPSBmcm9tKGxvYWRlcik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxvYWQkID0gbG9hZFRyYW5zbGF0aW9uLnBpcGUoXG4gICAgICAgIHJldHJ5KHRoaXMuY29uZmlnLmZhaWxlZFJldHJpZXMpLFxuICAgICAgICB0YXAodHJhbnNsYXRpb24gPT4ge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zbGF0aW9uKSkge1xuICAgICAgICAgICAgdHJhbnNsYXRpb24uZm9yRWFjaCh0ID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5oYW5kbGVTdWNjZXNzKHQubGFuZywgdC50cmFuc2xhdGlvbik7XG4gICAgICAgICAgICAgIC8vIFNhdmUgdGhlIGZhbGxiYWNrIGluIGNhY2hlIHNvIHdlJ2xsIG5vdCBjcmVhdGUgYSByZWR1bmRhbnQgcmVxdWVzdFxuICAgICAgICAgICAgICBpZiAodC5sYW5nICE9PSBwYXRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZS5zZXQodC5sYW5nLCBvZih7fSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5oYW5kbGVTdWNjZXNzKHBhdGgsIHRyYW5zbGF0aW9uKTtcbiAgICAgICAgfSksXG4gICAgICAgIGNhdGNoRXJyb3IoZXJyb3IgPT4ge1xuICAgICAgICAgIGlmICghdGhpcy5tZXJnZWRDb25maWcucHJvZE1vZGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHdoaWxlIHRyeWluZyB0byBsb2FkIFwiJHtwYXRofVwiYCwgZXJyb3IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZUZhaWx1cmUocGF0aCwgb3B0aW9ucyk7XG4gICAgICAgIH0pLFxuICAgICAgICBzaGFyZVJlcGxheSgxKVxuICAgICAgKTtcblxuICAgICAgdGhpcy5jYWNoZS5zZXQocGF0aCwgbG9hZCQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNhY2hlLmdldChwYXRoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBpbnN0YW50IHRyYW5zbGF0ZWQgdmFsdWUgb2YgYSBrZXlcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdHJhbnNsYXRlPHN0cmluZz4oJ2hlbGxvJylcbiAgICogdHJhbnNsYXRlKCdoZWxsbycsIHsgdmFsdWU6ICd2YWx1ZScgfSlcbiAgICogdHJhbnNsYXRlPHN0cmluZ1tdPihbJ2hlbGxvJywgJ2tleSddKVxuICAgKiB0cmFuc2xhdGUoJ2hlbGxvJywgeyB9LCAnZW4nKVxuICAgKiB0cmFuc2xhdGUoJ3Njb3BlLnNvbWVLZXknLCB7IH0sICdlbicpXG4gICAqL1xuICB0cmFuc2xhdGU8VCA9IGFueT4oa2V5OiBUcmFuc2xhdGVQYXJhbXMsIHBhcmFtczogSGFzaE1hcCA9IHt9LCBsYW5nID0gdGhpcy5nZXRBY3RpdmVMYW5nKCkpOiBUIHtcbiAgICBpZiAoIWtleSkgcmV0dXJuIGtleSBhcyBhbnk7XG5cbiAgICBjb25zdCB7IHNjb3BlLCByZXNvbHZlTGFuZyB9ID0gdGhpcy5yZXNvbHZlTGFuZ0FuZFNjb3BlKGxhbmcpO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoa2V5KSkge1xuICAgICAgcmV0dXJuIGtleS5tYXAoayA9PiB0aGlzLnRyYW5zbGF0ZShzY29wZSA/IGAke3Njb3BlfS4ke2t9YCA6IGssIHBhcmFtcywgcmVzb2x2ZUxhbmcpKSBhcyBhbnk7XG4gICAgfVxuXG4gICAga2V5ID0gc2NvcGUgPyBgJHtzY29wZX0uJHtrZXl9YCA6IGtleTtcblxuICAgIGNvbnN0IHRyYW5zbGF0aW9uID0gdGhpcy5nZXRUcmFuc2xhdGlvbihyZXNvbHZlTGFuZyk7XG4gICAgY29uc3QgdmFsdWUgPSB0cmFuc2xhdGlvbltrZXldO1xuXG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZU1pc3NpbmdLZXkoa2V5LCB2YWx1ZSwgcGFyYW1zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wYXJzZXIudHJhbnNwaWxlKHZhbHVlLCBwYXJhbXMsIHRyYW5zbGF0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB0cmFuc2xhdGVkIHZhbHVlIG9mIGEga2V5IGFzIG9ic2VydmFibGVcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogc2VsZWN0VHJhbnNsYXRlPHN0cmluZz4oJ2hlbGxvJykuc3Vic2NyaWJlKHZhbHVlID0+IC4uLilcbiAgICogc2VsZWN0VHJhbnNsYXRlPHN0cmluZz4oJ2hlbGxvJywge30sICdlcycpLnN1YnNjcmliZSh2YWx1ZSA9PiAuLi4pXG4gICAqIHNlbGVjdFRyYW5zbGF0ZTxzdHJpbmc+KCdoZWxsbycsIHt9LCAndG9kb3MnKS5zdWJzY3JpYmUodmFsdWUgPT4gLi4uKVxuICAgKiBzZWxlY3RUcmFuc2xhdGU8c3RyaW5nPignaGVsbG8nLCB7fSwgeyBzY29wZTogJ3RvZG9zJyB9KS5zdWJzY3JpYmUodmFsdWUgPT4gLi4uKVxuICAgKlxuICAgKi9cbiAgc2VsZWN0VHJhbnNsYXRlPFQgPSBhbnk+KFxuICAgIGtleTogVHJhbnNsYXRlUGFyYW1zLFxuICAgIHBhcmFtcz86IEhhc2hNYXAsXG4gICAgbGFuZz86IHN0cmluZyB8IFRyYW5zbG9jb1Njb3BlLFxuICAgIF9pc09iamVjdCA9IGZhbHNlXG4gICk6IE9ic2VydmFibGU8VD4ge1xuICAgIGxldCBpbmxpbmVMb2FkZXIgPSBudWxsO1xuICAgIGNvbnN0IGxvYWQgPSAobGFuZywgb3B0aW9ucz86IExvYWRPcHRpb25zKSA9PlxuICAgICAgdGhpcy5sb2FkKGxhbmcsIG9wdGlvbnMpLnBpcGUoXG4gICAgICAgIG1hcCgoKSA9PiAoX2lzT2JqZWN0ID8gdGhpcy50cmFuc2xhdGVPYmplY3Qoa2V5LCBwYXJhbXMsIGxhbmcpIDogdGhpcy50cmFuc2xhdGUoa2V5LCBwYXJhbXMsIGxhbmcpKSlcbiAgICAgICk7XG4gICAgaWYgKGlzTmlsKGxhbmcpKSB7XG4gICAgICByZXR1cm4gdGhpcy5sYW5nQ2hhbmdlcyQucGlwZShzd2l0Y2hNYXAobGFuZyA9PiBsb2FkKGxhbmcpKSk7XG4gICAgfVxuXG4gICAgaWYgKGlzU2NvcGVPYmplY3QobGFuZykpIHtcbiAgICAgIC8vIGl0J3MgYSBzY29wZSBvYmplY3QuXG4gICAgICBjb25zdCBwcm92aWRlclNjb3BlID0gbGFuZyBhcyBQcm92aWRlclNjb3BlO1xuICAgICAgbGFuZyA9IHByb3ZpZGVyU2NvcGUuc2NvcGU7XG4gICAgICBpbmxpbmVMb2FkZXIgPSByZXNvbHZlSW5saW5lTG9hZGVyKHByb3ZpZGVyU2NvcGUsIHByb3ZpZGVyU2NvcGUuc2NvcGUpO1xuICAgIH1cblxuICAgIGxhbmcgPSBsYW5nIGFzIHN0cmluZztcbiAgICBpZiAodGhpcy5pc0xhbmcobGFuZykgfHwgdGhpcy5pc1Njb3BlV2l0aExhbmcobGFuZykpIHtcbiAgICAgIHJldHVybiBsb2FkKGxhbmcpO1xuICAgIH1cbiAgICAvLyBpdCdzIGEgc2NvcGVcbiAgICBjb25zdCBzY29wZSA9IGxhbmc7XG4gICAgcmV0dXJuIHRoaXMubGFuZ0NoYW5nZXMkLnBpcGUoc3dpdGNoTWFwKGxhbmcgPT4gbG9hZChgJHtzY29wZX0vJHtsYW5nfWAsIHsgaW5saW5lTG9hZGVyIH0pKSk7XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciB0aGUgc2NvcGUgd2l0aCBsYW5nXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHRvZG9zL2VuID0+IHRydWVcbiAgICogdG9kb3MgPT4gZmFsc2VcbiAgICovXG4gIHByaXZhdGUgaXNTY29wZVdpdGhMYW5nKGxhbmc6IHN0cmluZykge1xuICAgIHJldHVybiB0aGlzLmlzTGFuZyhnZXRMYW5nRnJvbVNjb3BlKGxhbmcpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2xhdGUgdGhlIGdpdmVuIHBhdGggdGhhdCByZXR1cm5zIGFuIG9iamVjdFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBzZXJ2aWNlLnRyYW5zbGF0ZU9iamVjdCgncGF0aC50by5vYmplY3QnLCB7J3N1YnBhdGgnOiB7IHZhbHVlOiAnc29tZVZhbHVlJ319KSA9PiByZXR1cm5zIHRyYW5zbGF0ZWQgb2JqZWN0XG4gICAqXG4gICAqL1xuICB0cmFuc2xhdGVPYmplY3Q8VCA9IGFueT4oa2V5OiBzdHJpbmcsIHBhcmFtcz86IEhhc2hNYXAsIGxhbmc/OiBzdHJpbmcpOiBUO1xuICB0cmFuc2xhdGVPYmplY3Q8VCA9IGFueT4oa2V5OiBzdHJpbmdbXSwgcGFyYW1zPzogSGFzaE1hcCwgbGFuZz86IHN0cmluZyk6IFRbXTtcbiAgdHJhbnNsYXRlT2JqZWN0PFQgPSBhbnk+KGtleTogVHJhbnNsYXRlUGFyYW1zLCBwYXJhbXM/OiBIYXNoTWFwLCBsYW5nPzogc3RyaW5nKTogVCB8IFRbXTtcbiAgdHJhbnNsYXRlT2JqZWN0PFQgPSBhbnk+KGtleTogSGFzaE1hcCB8IE1hcDxzdHJpbmcsIEhhc2hNYXA+LCBwYXJhbXM/OiBudWxsLCBsYW5nPzogc3RyaW5nKTogVFtdO1xuICB0cmFuc2xhdGVPYmplY3Q8VCA9IGFueT4oa2V5OiBUcmFuc2xhdGVPYmplY3RQYXJhbXMsIHBhcmFtcz86IEhhc2hNYXAsIGxhbmcgPSB0aGlzLmdldEFjdGl2ZUxhbmcoKSk6IFQgfCBUW10ge1xuICAgIGlmIChpc1N0cmluZyhrZXkpIHx8IEFycmF5LmlzQXJyYXkoa2V5KSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoa2V5KSkge1xuICAgICAgICByZXR1cm4ga2V5Lm1hcChrID0+IHRoaXMudHJhbnNsYXRlT2JqZWN0KHNjb3BlID8gYCR7c2NvcGV9LiR7a31gIDogaywgcGFyYW1zLCByZXNvbHZlTGFuZykpIGFzIGFueTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgcmVzb2x2ZUxhbmcsIHNjb3BlIH0gPSB0aGlzLnJlc29sdmVMYW5nQW5kU2NvcGUobGFuZyk7XG5cbiAgICAgIGNvbnN0IHRyYW5zbGF0aW9uID0gdGhpcy5nZXRUcmFuc2xhdGlvbihyZXNvbHZlTGFuZyk7XG4gICAgICBrZXkgPSBzY29wZSA/IGAke3Njb3BlfS4ke2tleX1gIDoga2V5O1xuXG4gICAgICBjb25zdCB2YWx1ZSA9IHVuZmxhdHRlbih0aGlzLmdldE9iamVjdEJ5S2V5KHRyYW5zbGF0aW9uLCBrZXkpKTtcbiAgICAgIC8qIElmIGFuIGVtcHR5IG9iamVjdCB3YXMgcmV0dXJuZWQgd2Ugd2FudCB0byB0cnkgYW5kIHRyYW5zbGF0ZSB0aGUga2V5IGFzIGEgc3RyaW5nIGFuZCBub3QgYW4gb2JqZWN0ICovXG4gICAgICByZXR1cm4gaXNFbXB0eSh2YWx1ZSkgPyB0aGlzLnRyYW5zbGF0ZShrZXksIHBhcmFtcywgbGFuZykgOiB0aGlzLnBhcnNlci50cmFuc3BpbGUodmFsdWUsIHBhcmFtcywgdHJhbnNsYXRpb24pO1xuICAgIH1cblxuICAgIGNvbnN0IHRyYW5zbGF0aW9uczogVFtdID0gW107XG4gICAgZm9yIChjb25zdCBbX2tleSwgX3BhcmFtc10gb2YgdGhpcy5nZXRFbnRyaWVzKGtleSkpIHtcbiAgICAgIHRyYW5zbGF0aW9ucy5wdXNoKHRoaXMudHJhbnNsYXRlT2JqZWN0KF9rZXksIF9wYXJhbXMsIGxhbmcpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJhbnNsYXRpb25zO1xuICB9XG5cbiAgc2VsZWN0VHJhbnNsYXRlT2JqZWN0PFQgPSBhbnk+KGtleTogc3RyaW5nLCBwYXJhbXM/OiBIYXNoTWFwLCBsYW5nPzogc3RyaW5nKTogT2JzZXJ2YWJsZTxUPjtcbiAgc2VsZWN0VHJhbnNsYXRlT2JqZWN0PFQgPSBhbnk+KGtleTogc3RyaW5nW10sIHBhcmFtcz86IEhhc2hNYXAsIGxhbmc/OiBzdHJpbmcpOiBPYnNlcnZhYmxlPFRbXT47XG4gIHNlbGVjdFRyYW5zbGF0ZU9iamVjdDxUID0gYW55PihrZXk6IEhhc2hNYXAgfCBNYXA8c3RyaW5nLCBIYXNoTWFwPiwgcGFyYW1zPzogbnVsbCwgbGFuZz86IHN0cmluZyk6IE9ic2VydmFibGU8VFtdPjtcbiAgc2VsZWN0VHJhbnNsYXRlT2JqZWN0PFQgPSBhbnk+KFxuICAgIGtleTogVHJhbnNsYXRlT2JqZWN0UGFyYW1zLFxuICAgIHBhcmFtcz86IEhhc2hNYXAsXG4gICAgbGFuZz86IHN0cmluZ1xuICApOiBPYnNlcnZhYmxlPFQ+IHwgT2JzZXJ2YWJsZTxUW10+IHtcbiAgICBpZiAoaXNTdHJpbmcoa2V5KSB8fCBBcnJheS5pc0FycmF5KGtleSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlbGVjdFRyYW5zbGF0ZTxUPihrZXksIHBhcmFtcywgbGFuZywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgY29uc3QgW1tmaXJzdEtleSwgZmlyc3RQYXJhbXNdLCAuLi5yZXN0XSA9IHRoaXMuZ2V0RW50cmllcyhrZXkpO1xuXG4gICAgLyogSW4gb3JkZXIgdG8gYXZvaWQgc3Vic2NyaWJpbmcgbXVsdGlwbGUgdGltZXMgdG8gdGhlIGxvYWQgbGFuZ3VhZ2UgZXZlbnQgYnkgY2FsbGluZyBzZWxlY3RUcmFuc2xhdGVPYmplY3QgZm9yIGVhY2ggcGFpcixcbiAgICAgKiB3ZSBsaXN0ZW4gdG8gd2hlbiB0aGUgZmlyc3Qga2V5IGhhcyBiZWVuIHRyYW5zbGF0ZWQgKHRoZSBsYW5ndWFnZSBpcyBsb2FkZWQpIGFuZCB0cmFuc2xhdGUgdGhlIHJlc3Qgc3luY2hyb25vdXNseSAqL1xuICAgIHJldHVybiB0aGlzLnNlbGVjdFRyYW5zbGF0ZU9iamVjdDxUPihmaXJzdEtleSwgZmlyc3RQYXJhbXMsIGxhbmcpLnBpcGUoXG4gICAgICBtYXAodmFsdWUgPT4ge1xuICAgICAgICBjb25zdCB0cmFuc2xhdGlvbnMgPSBbdmFsdWVdO1xuICAgICAgICBmb3IgKGNvbnN0IFtfa2V5LCBfcGFyYW1zXSBvZiByZXN0KSB7XG4gICAgICAgICAgdHJhbnNsYXRpb25zLnB1c2godGhpcy50cmFuc2xhdGVPYmplY3Q8VD4oX2tleSwgX3BhcmFtcywgbGFuZykpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRyYW5zbGF0aW9ucztcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuIG9iamVjdCBvZiB0cmFuc2xhdGlvbnMgZm9yIGEgZ2l2ZW4gbGFuZ3VhZ2VcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogZ2V0VHJhbnNsYXRpb24oKVxuICAgKiBnZXRUcmFuc2xhdGlvbignZW4nKVxuICAgKiBnZXRUcmFuc2xhdGlvbignYWRtaW4tcGFnZS9lbicpXG4gICAqL1xuICBnZXRUcmFuc2xhdGlvbigpOiBNYXA8c3RyaW5nLCBUcmFuc2xhdGlvbj47XG4gIGdldFRyYW5zbGF0aW9uKGxhbmdPclNjb3BlOiBzdHJpbmcpOiBUcmFuc2xhdGlvbjtcbiAgZ2V0VHJhbnNsYXRpb24obGFuZ09yU2NvcGU/OiBzdHJpbmcpOiBNYXA8c3RyaW5nLCBUcmFuc2xhdGlvbj4gfCBUcmFuc2xhdGlvbiB7XG4gICAgaWYgKGxhbmdPclNjb3BlKSB7XG4gICAgICBpZiAodGhpcy5pc0xhbmcobGFuZ09yU2NvcGUpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0aW9ucy5nZXQobGFuZ09yU2NvcGUpIHx8IHt9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIHNjb3BlLCBidWlsZCB0aGUgc2NvcGUgdmFsdWUgZnJvbSB0aGUgdHJhbnNsYXRpb24gb2JqZWN0XG4gICAgICAgIGNvbnN0IHsgc2NvcGUsIHJlc29sdmVMYW5nIH0gPSB0aGlzLnJlc29sdmVMYW5nQW5kU2NvcGUobGFuZ09yU2NvcGUpO1xuICAgICAgICBjb25zdCB0cmFuc2xhdGlvbiA9IHRoaXMudHJhbnNsYXRpb25zLmdldChyZXNvbHZlTGFuZykgfHwge307XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T2JqZWN0QnlLZXkodHJhbnNsYXRpb24sIHNjb3BlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy50cmFuc2xhdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbiBvYmplY3Qgb2YgdHJhbnNsYXRpb25zIGZvciBhIGdpdmVuIGxhbmd1YWdlXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHNlbGVjdFRyYW5zbGF0aW9uKCkuc3Vic2NyaWJlKCkgLSB3aWxsIHJldHVybiB0aGUgY3VycmVudCBsYW5nIHRyYW5zbGF0aW9uXG4gICAqIHNlbGVjdFRyYW5zbGF0aW9uKCdlcycpLnN1YnNjcmliZSgpXG4gICAqIHNlbGVjdFRyYW5zbGF0aW9uKCdhZG1pbi1wYWdlJykuc3Vic2NyaWJlKCkgLSB3aWxsIHJldHVybiB0aGUgY3VycmVudCBsYW5nIHNjb3BlIHRyYW5zbGF0aW9uXG4gICAqIHNlbGVjdFRyYW5zbGF0aW9uKCdhZG1pbi1wYWdlL2VzJykuc3Vic2NyaWJlKClcbiAgICovXG4gIHNlbGVjdFRyYW5zbGF0aW9uKGxhbmc/OiBzdHJpbmcpOiBPYnNlcnZhYmxlPFRyYW5zbGF0aW9uPiB7XG4gICAgbGV0IGxhbmd1YWdlJCA9IHRoaXMubGFuZ0NoYW5nZXMkO1xuICAgIGlmIChsYW5nKSB7XG4gICAgICBjb25zdCBzY29wZUxhbmdTcGVjaWZpZWQgPSBnZXRMYW5nRnJvbVNjb3BlKGxhbmcpICE9PSBsYW5nO1xuICAgICAgaWYgKHRoaXMuaXNMYW5nKGxhbmcpIHx8IHNjb3BlTGFuZ1NwZWNpZmllZCkge1xuICAgICAgICBsYW5ndWFnZSQgPSBvZihsYW5nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxhbmd1YWdlJCA9IHRoaXMubGFuZ0NoYW5nZXMkLnBpcGUobWFwKGN1cnJlbnRMYW5nID0+IGAke2xhbmd9LyR7Y3VycmVudExhbmd9YCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBsYW5ndWFnZSQucGlwZShzd2l0Y2hNYXAobGFuZ3VhZ2UgPT4gdGhpcy5sb2FkKGxhbmd1YWdlKS5waXBlKG1hcCgoKSA9PiB0aGlzLmdldFRyYW5zbGF0aW9uKGxhbmd1YWdlKSkpKSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBvciBtZXJnZSBhIGdpdmVuIHRyYW5zbGF0aW9uIG9iamVjdCB0byBjdXJyZW50IGxhbmdcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogc2V0VHJhbnNsYXRpb24oeyAuLi4gfSlcbiAgICogc2V0VHJhbnNsYXRpb24oeyAuLi4gfSwgJ2VuJylcbiAgICogc2V0VHJhbnNsYXRpb24oeyAuLi4gfSwgJ2VzJywgeyBtZXJnZTogZmFsc2UgfSApXG4gICAqIHNldFRyYW5zbGF0aW9uKHsgLi4uIH0sICd0b2Rvcy9lbicsIHsgbWVyZ2U6IGZhbHNlIH0gKVxuICAgKi9cbiAgc2V0VHJhbnNsYXRpb24odHJhbnNsYXRpb246IFRyYW5zbGF0aW9uLCBsYW5nID0gdGhpcy5nZXRBY3RpdmVMYW5nKCksIG9wdGlvbnM6IFNldFRyYW5zbGF0aW9uT3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgZGVmYXVsdHMgPSB7IG1lcmdlOiB0cnVlLCBlbWl0Q2hhbmdlOiB0cnVlIH07XG4gICAgY29uc3QgbWVyZ2VkT3B0aW9ucyA9IHsgLi4uZGVmYXVsdHMsIC4uLm9wdGlvbnMgfTtcbiAgICBjb25zdCBzY29wZSA9IGdldFNjb3BlRnJvbUxhbmcobGFuZyk7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGlzIGlzbid0IGEgc2NvcGUgd2UgdXNlIHRoZSB3aG9sZSB0cmFuc2xhdGlvbiBhcyBpc1xuICAgICAqIG90aGVyd2lzZSB3ZSBuZWVkIHRvIGZsYXQgdGhlIHNjb3BlIGFuZCB1c2UgaXRcbiAgICAgKi9cbiAgICBsZXQgZmxhdHRlblNjb3BlT3JUcmFuc2xhdGlvbiA9IHRyYW5zbGF0aW9uO1xuXG4gICAgLy8gTWVyZ2VkIHRoZSBzY29wZWQgbGFuZ3VhZ2UgaW50byB0aGUgYWN0aXZlIGxhbmd1YWdlXG4gICAgaWYgKHNjb3BlKSB7XG4gICAgICBjb25zdCBrZXkgPSB0aGlzLmdldE1hcHBlZFNjb3BlKHNjb3BlKTtcbiAgICAgIGZsYXR0ZW5TY29wZU9yVHJhbnNsYXRpb24gPSBmbGF0dGVuKHsgW2tleV06IHRyYW5zbGF0aW9uIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGN1cnJlbnRMYW5nID0gc2NvcGUgPyBnZXRMYW5nRnJvbVNjb3BlKGxhbmcpIDogbGFuZztcblxuICAgIGNvbnN0IG1lcmdlZFRyYW5zbGF0aW9uID0ge1xuICAgICAgLi4uKG1lcmdlZE9wdGlvbnMubWVyZ2UgJiYgdGhpcy5nZXRUcmFuc2xhdGlvbihjdXJyZW50TGFuZykpLFxuICAgICAgLi4uZmxhdHRlblNjb3BlT3JUcmFuc2xhdGlvblxuICAgIH07XG5cbiAgICBjb25zdCBmbGF0dGVuVHJhbnNsYXRpb24gPSB0aGlzLm1lcmdlZENvbmZpZy5mbGF0dGVuLmFvdCA/IG1lcmdlZFRyYW5zbGF0aW9uIDogZmxhdHRlbihtZXJnZWRUcmFuc2xhdGlvbik7XG4gICAgY29uc3Qgd2l0aEhvb2sgPSB0aGlzLmludGVyY2VwdG9yLnByZVNhdmVUcmFuc2xhdGlvbihmbGF0dGVuVHJhbnNsYXRpb24sIGN1cnJlbnRMYW5nKTtcbiAgICB0aGlzLnRyYW5zbGF0aW9ucy5zZXQoY3VycmVudExhbmcsIHdpdGhIb29rKTtcbiAgICBtZXJnZWRPcHRpb25zLmVtaXRDaGFuZ2UgJiYgdGhpcy5zZXRBY3RpdmVMYW5nKHRoaXMuZ2V0QWN0aXZlTGFuZygpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRyYW5zbGF0aW9uIGtleSB3aXRoIGdpdmVuIHZhbHVlXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHNldFRyYW5zbGF0aW9uS2V5KCdrZXknLCAndmFsdWUnKVxuICAgKiBzZXRUcmFuc2xhdGlvbktleSgna2V5Lm5lc3RlZCcsICd2YWx1ZScpXG4gICAqIHNldFRyYW5zbGF0aW9uS2V5KCdrZXkubmVzdGVkJywgJ3ZhbHVlJywgJ2VuJylcbiAgICogc2V0VHJhbnNsYXRpb25LZXkoJ2tleS5uZXN0ZWQnLCAndmFsdWUnLCAnZW4nLCB7IGVtaXRDaGFuZ2U6IGZhbHNlIH0gKVxuICAgKi9cbiAgc2V0VHJhbnNsYXRpb25LZXkoXG4gICAga2V5OiBzdHJpbmcsXG4gICAgdmFsdWU6IHN0cmluZyxcbiAgICBsYW5nID0gdGhpcy5nZXRBY3RpdmVMYW5nKCksXG4gICAgLy8gVG9kbzogVXNlIE9taXQgYW5kIG1lcmdlIG9wdGlvbnMgYW5kIGxhbmcgdG8gb25lIG9iamVjdCBpbiB2M1xuICAgIG9wdGlvbnM6IHsgZW1pdENoYW5nZT86IFNldFRyYW5zbGF0aW9uT3B0aW9uc1snZW1pdENoYW5nZSddIH0gPSB7fVxuICApIHtcbiAgICBjb25zdCB3aXRoSG9vayA9IHRoaXMuaW50ZXJjZXB0b3IucHJlU2F2ZVRyYW5zbGF0aW9uS2V5KGtleSwgdmFsdWUsIGxhbmcpO1xuICAgIGNvbnN0IG5ld1ZhbHVlID0ge1xuICAgICAgW2tleV06IHdpdGhIb29rXG4gICAgfTtcblxuICAgIHRoaXMuc2V0VHJhbnNsYXRpb24obmV3VmFsdWUsIGxhbmcsIHsgLi4ub3B0aW9ucywgbWVyZ2U6IHRydWUgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZmFsbGJhY2sgbGFuZyBmb3IgdGhlIGN1cnJlbnRseSBhY3RpdmUgbGFuZ3VhZ2VcbiAgICogQHBhcmFtIGZhbGxiYWNrTGFuZ1xuICAgKi9cbiAgc2V0RmFsbGJhY2tMYW5nRm9yTWlzc2luZ1RyYW5zbGF0aW9uKHsgZmFsbGJhY2tMYW5nIH06IFBpY2s8VHJhbnNsb2NvQ29uZmlnLCAnZmFsbGJhY2tMYW5nJz4pOiB2b2lkIHtcbiAgICBjb25zdCBsYW5nID0gQXJyYXkuaXNBcnJheShmYWxsYmFja0xhbmcpID8gZmFsbGJhY2tMYW5nWzBdIDogZmFsbGJhY2tMYW5nO1xuICAgIGlmICh0aGlzLnVzZUZhbGxiYWNrVHJhbnNsYXRpb24obGFuZykgJiYgZmFsbGJhY2tMYW5nKSB7XG4gICAgICB0aGlzLmZpcnN0RmFsbGJhY2tMYW5nID0gbGFuZztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfaGFuZGxlTWlzc2luZ0tleShrZXk6IHN0cmluZywgdmFsdWU6IGFueSwgcGFyYW1zPzogSGFzaE1hcCkge1xuICAgIGlmICh0aGlzLmNvbmZpZy5taXNzaW5nSGFuZGxlci5hbGxvd0VtcHR5ICYmIHZhbHVlID09PSAnJykge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnVzZUZhbGxiYWNrVHJhbnNsYXRpb24oKSAmJiAhdGhpcy5pc1Jlc29sdmVkTWlzc2luZ09uY2UpIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gc2V0IGl0IHRvIHRydWUgdG8gcHJldmVudCBhIGxvb3BcbiAgICAgIHRoaXMuaXNSZXNvbHZlZE1pc3NpbmdPbmNlID0gdHJ1ZTtcbiAgICAgIGNvbnN0IGZhbGxiYWNrVmFsdWUgPSB0aGlzLnRyYW5zbGF0ZShrZXksIHBhcmFtcywgdGhpcy5maXJzdEZhbGxiYWNrTGFuZyk7XG4gICAgICB0aGlzLmlzUmVzb2x2ZWRNaXNzaW5nT25jZSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGZhbGxiYWNrVmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubWlzc2luZ0hhbmRsZXIuaGFuZGxlKGtleSwgdGhpcy5nZXRNaXNzaW5nSGFuZGxlckRhdGEoKSwgcGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9pc0xhbmdTY29wZWQobGFuZzogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QXZhaWxhYmxlTGFuZ3NJZHMoKS5pbmRleE9mKGxhbmcpID09PSAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBnaXZlbiBzdHJpbmcgaXMgb25lIG9mIHRoZSBzcGVjaWZpZWQgYXZhaWxhYmxlIGxhbmd1YWdlcy5cbiAgICogQHJldHVybnNcbiAgICogVHJ1ZSBpZiB0aGUgZ2l2ZW4gc3RyaW5nIGlzIGFuIGF2YWlsYWJsZSBsYW5ndWFnZS5cbiAgICogRmFsc2UgaWYgdGhlIGdpdmVuIHN0cmluZyBpcyBub3QgYW4gYXZhaWxhYmxlIGxhbmd1YWdlLlxuICAgKi9cbiAgaXNMYW5nKGxhbmc6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmdldEF2YWlsYWJsZUxhbmdzSWRzKCkuaW5kZXhPZihsYW5nKSAhPT0gLTE7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqXG4gICAqIFdlIGFsd2F5cyB3YW50IHRvIG1ha2Ugc3VyZSB0aGUgZ2xvYmFsIGxhbmcgaXMgbG9hZGVkXG4gICAqIGJlZm9yZSBsb2FkaW5nIHRoZSBzY29wZSBzaW5jZSB5b3UgY2FuIGFjY2VzcyBib3RoIHZpYSB0aGUgcGlwZS9kaXJlY3RpdmUuXG4gICAqL1xuICBfbG9hZERlcGVuZGVuY2llcyhwYXRoOiBzdHJpbmcsIGlubGluZUxvYWRlcj86IElubGluZUxvYWRlcik6IE9ic2VydmFibGU8VHJhbnNsYXRpb24gfCBUcmFuc2xhdGlvbltdPiB7XG4gICAgY29uc3QgbWFpbkxhbmcgPSBnZXRMYW5nRnJvbVNjb3BlKHBhdGgpO1xuXG4gICAgaWYgKHRoaXMuX2lzTGFuZ1Njb3BlZChwYXRoKSAmJiAhdGhpcy5pc0xvYWRlZFRyYW5zbGF0aW9uKG1haW5MYW5nKSkge1xuICAgICAgcmV0dXJuIGNvbWJpbmVMYXRlc3QodGhpcy5sb2FkKG1haW5MYW5nKSwgdGhpcy5sb2FkKHBhdGgsIHsgaW5saW5lTG9hZGVyIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubG9hZChwYXRoLCB7IGlubGluZUxvYWRlciB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9jb21wbGV0ZVNjb3BlV2l0aExhbmcobGFuZ09yU2NvcGU6IHN0cmluZykge1xuICAgIGlmICh0aGlzLl9pc0xhbmdTY29wZWQobGFuZ09yU2NvcGUpICYmICF0aGlzLmlzTGFuZyhnZXRMYW5nRnJvbVNjb3BlKGxhbmdPclNjb3BlKSkpIHtcbiAgICAgIHJldHVybiBgJHtsYW5nT3JTY29wZX0vJHt0aGlzLmdldEFjdGl2ZUxhbmcoKX1gO1xuICAgIH1cbiAgICByZXR1cm4gbGFuZ09yU2NvcGU7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfc2V0U2NvcGVBbGlhcyhzY29wZTogc3RyaW5nLCBhbGlhczogc3RyaW5nKSB7XG4gICAgaWYgKCF0aGlzLm1lcmdlZENvbmZpZy5zY29wZU1hcHBpbmcpIHtcbiAgICAgIHRoaXMubWVyZ2VkQ29uZmlnLnNjb3BlTWFwcGluZyA9IHt9O1xuICAgIH1cbiAgICB0aGlzLm1lcmdlZENvbmZpZy5zY29wZU1hcHBpbmdbc2NvcGVdID0gYWxpYXM7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5zdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAvLyBDYXJldGFrZXIgbm90ZTogaXQncyBpbXBvcnRhbnQgdG8gY2xlYW4gdXAgcmVmZXJlbmNlcyB0byBzdWJzY3JpcHRpb25zIHNpbmNlIHRoZXkgc2F2ZSB0aGUgYG5leHRgXG4gICAgICAvLyBjYWxsYmFjayB3aXRoaW4gaXRzIGBkZXN0aW5hdGlvbmAgcHJvcGVydHksIHByZXZlbnRpbmcgY2xhc3NlcyBmcm9tIGJlaW5nIEdDJ2QuXG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgfVxuICAgIC8vIENhcmV0YWtlciBub3RlOiBzaW5jZSB0aGlzIGlzIHRoZSByb290IHByb3ZpZGVyLCBpdCdsbCBiZSBkZXN0cm95ZWQgd2hlbiB0aGUgYE5nTW9kdWxlUmVmLmRlc3Ryb3koKWAgaXMgcnVuLlxuICAgIC8vIENhY2hlZCB2YWx1ZXMgY2FwdHVyZSBgdGhpc2AsIHRodXMgbGVhZGluZyB0byBhIGNpcmN1bGFyIHJlZmVyZW5jZSBhbmQgcHJldmVudGluZyB0aGUgYFRyYW5zbG9jb1NlcnZpY2VgIGZyb21cbiAgICAvLyBiZWluZyBHQydkLiBUaGlzIHdvdWxkIGxlYWQgdG8gYSBtZW1vcnkgbGVhayB3aGVuIHNlcnZlci1zaWRlIHJlbmRlcmluZyBpcyB1c2VkIHNpbmNlIHRoZSBzZXJ2aWNlIGlzIGNyZWF0ZWRcbiAgICAvLyBhbmQgZGVzdHJveWVkIHBlciBlYWNoIEhUVFAgcmVxdWVzdCwgYnV0IGFueSBzZXJ2aWNlIGlzIG5vdCBnZXR0aW5nIEdDJ2QuXG4gICAgdGhpcy5jYWNoZS5jbGVhcigpO1xuICB9XG5cbiAgcHJpdmF0ZSBpc0xvYWRlZFRyYW5zbGF0aW9uKGxhbmc6IHN0cmluZykge1xuICAgIHJldHVybiBzaXplKHRoaXMuZ2V0VHJhbnNsYXRpb24obGFuZykpO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRBdmFpbGFibGVMYW5nc0lkcygpOiBzdHJpbmdbXSB7XG4gICAgY29uc3QgZmlyc3QgPSB0aGlzLmdldEF2YWlsYWJsZUxhbmdzKClbMF07XG5cbiAgICBpZiAoaXNTdHJpbmcoZmlyc3QpKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRBdmFpbGFibGVMYW5ncygpIGFzIHN0cmluZ1tdO1xuICAgIH1cblxuICAgIHJldHVybiAodGhpcy5nZXRBdmFpbGFibGVMYW5ncygpIGFzIHsgaWQ6IHN0cmluZyB9W10pLm1hcChsID0+IGwuaWQpO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRNaXNzaW5nSGFuZGxlckRhdGEoKTogVHJhbnNsb2NvTWlzc2luZ0hhbmRsZXJEYXRhIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4udGhpcy5jb25maWcsXG4gICAgICBhY3RpdmVMYW5nOiB0aGlzLmdldEFjdGl2ZUxhbmcoKSxcbiAgICAgIGF2YWlsYWJsZUxhbmdzOiB0aGlzLmF2YWlsYWJsZUxhbmdzLFxuICAgICAgZGVmYXVsdExhbmc6IHRoaXMuZGVmYXVsdExhbmdcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSBhIGZhbGxiYWNrIHRyYW5zbGF0aW9uIHNldCBmb3IgbWlzc2luZyBrZXlzIG9mIHRoZSBwcmltYXJ5IGxhbmd1YWdlXG4gICAqIFRoaXMgaXMgdW5yZWxhdGVkIHRvIHRoZSBmYWxsYmFjayBsYW5ndWFnZSAod2hpY2ggY2hhbmdlcyB0aGUgYWN0aXZlIGxhbmd1YWdlKVxuICAgKi9cbiAgcHJpdmF0ZSB1c2VGYWxsYmFja1RyYW5zbGF0aW9uKGxhbmc/OiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcubWlzc2luZ0hhbmRsZXIudXNlRmFsbGJhY2tUcmFuc2xhdGlvbiAmJiBsYW5nICE9PSB0aGlzLmZpcnN0RmFsbGJhY2tMYW5nO1xuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVTdWNjZXNzKGxhbmc6IHN0cmluZywgdHJhbnNsYXRpb246IFRyYW5zbGF0aW9uKSB7XG4gICAgdGhpcy5zZXRUcmFuc2xhdGlvbih0cmFuc2xhdGlvbiwgbGFuZywgeyBlbWl0Q2hhbmdlOiBmYWxzZSB9KTtcbiAgICB0aGlzLmV2ZW50cy5uZXh0KHtcbiAgICAgIHdhc0ZhaWx1cmU6ICEhdGhpcy5mYWlsZWRMYW5ncy5zaXplLFxuICAgICAgdHlwZTogJ3RyYW5zbGF0aW9uTG9hZFN1Y2Nlc3MnLFxuICAgICAgcGF5bG9hZDogZ2V0RXZlbnRQYXlsb2FkKGxhbmcpXG4gICAgfSk7XG4gICAgdGhpcy5mYWlsZWRMYW5ncy5mb3JFYWNoKGwgPT4gdGhpcy5jYWNoZS5kZWxldGUobCkpO1xuICAgIHRoaXMuZmFpbGVkTGFuZ3MuY2xlYXIoKTtcbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlRmFpbHVyZShsYW5nOiBzdHJpbmcsIGxvYWRPcHRpb25zOiBMb2FkT3B0aW9ucykge1xuICAgIC8vIFdoZW4gc3RhcnRpbmcgdG8gbG9hZCBhIGZpcnN0IGNob2ljZSBsYW5ndWFnZSwgaW5pdGlhbGl6ZVxuICAgIC8vIHRoZSBmYWlsZWQgY291bnRlciBhbmQgcmVzb2x2ZSB0aGUgZmFsbGJhY2sgbGFuZ3MuXG4gICAgaWYgKGlzTmlsKGxvYWRPcHRpb25zLmZhaWxlZENvdW50ZXIpKSB7XG4gICAgICBsb2FkT3B0aW9ucy5mYWlsZWRDb3VudGVyID0gMDtcblxuICAgICAgaWYgKCFsb2FkT3B0aW9ucy5mYWxsYmFja0xhbmdzKSB7XG4gICAgICAgIGxvYWRPcHRpb25zLmZhbGxiYWNrTGFuZ3MgPSB0aGlzLmZhbGxiYWNrU3RyYXRlZ3kuZ2V0TmV4dExhbmdzKGxhbmcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHNwbGl0dGVkID0gbGFuZy5zcGxpdCgnLycpO1xuICAgIGNvbnN0IGZhbGxiYWNrcyA9IGxvYWRPcHRpb25zLmZhbGxiYWNrTGFuZ3M7XG4gICAgY29uc3QgbmV4dExhbmcgPSBmYWxsYmFja3NbbG9hZE9wdGlvbnMuZmFpbGVkQ291bnRlcl07XG4gICAgdGhpcy5mYWlsZWRMYW5ncy5hZGQobGFuZyk7XG5cbiAgICAvLyBUaGlzIGhhbmRsZXMgdGhlIGNhc2Ugd2hlcmUgYSBsb2FkZWQgZmFsbGJhY2sgbGFuZ3VhZ2UgaXMgcmVxdWVzdGVkIGFnYWluXG4gICAgaWYgKHRoaXMuY2FjaGUuaGFzKG5leHRMYW5nKSkge1xuICAgICAgdGhpcy5oYW5kbGVTdWNjZXNzKG5leHRMYW5nLCB0aGlzLmdldFRyYW5zbGF0aW9uKG5leHRMYW5nKSk7XG4gICAgICByZXR1cm4gRU1QVFk7XG4gICAgfVxuXG4gICAgY29uc3QgaXNGYWxsYmFja0xhbmcgPSBuZXh0TGFuZyA9PT0gc3BsaXR0ZWRbc3BsaXR0ZWQubGVuZ3RoIC0gMV07XG5cbiAgICBpZiAoIW5leHRMYW5nIHx8IGlzRmFsbGJhY2tMYW5nKSB7XG4gICAgICBsZXQgbXNnID0gYFVuYWJsZSB0byBsb2FkIHRyYW5zbGF0aW9uIGFuZCBhbGwgdGhlIGZhbGxiYWNrIGxhbmd1YWdlc2A7XG4gICAgICBpZiAoc3BsaXR0ZWQubGVuZ3RoID4gMSkge1xuICAgICAgICBtc2cgKz0gYCwgZGlkIHlvdSBtaXNzcGVsbGVkIHRoZSBzY29wZSBuYW1lP2A7XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cblxuICAgIGxldCByZXNvbHZlTGFuZyA9IG5leHRMYW5nO1xuICAgIC8vIGlmIGl0J3Mgc2NvcGVkIGxhbmdcbiAgICBpZiAoc3BsaXR0ZWQubGVuZ3RoID4gMSkge1xuICAgICAgLy8gV2UgbmVlZCB0byByZXNvbHZlIGl0IHRvOlxuICAgICAgLy8gdG9kb3MvbGFuZ05vdEV4aXN0cyA9PiB0b2Rvcy9uZXh0TGFuZ1xuICAgICAgc3BsaXR0ZWRbc3BsaXR0ZWQubGVuZ3RoIC0gMV0gPSBuZXh0TGFuZztcbiAgICAgIHJlc29sdmVMYW5nID0gc3BsaXR0ZWQuam9pbignLycpO1xuICAgIH1cblxuICAgIGxvYWRPcHRpb25zLmZhaWxlZENvdW50ZXIrKztcbiAgICB0aGlzLmV2ZW50cy5uZXh0KHtcbiAgICAgIHR5cGU6ICd0cmFuc2xhdGlvbkxvYWRGYWlsdXJlJyxcbiAgICAgIHBheWxvYWQ6IGdldEV2ZW50UGF5bG9hZChsYW5nKVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMubG9hZChyZXNvbHZlTGFuZywgbG9hZE9wdGlvbnMpO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRNYXBwZWRTY29wZShzY29wZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCB7IHNjb3BlTWFwcGluZyA9IHt9IH0gPSB0aGlzLmNvbmZpZztcbiAgICByZXR1cm4gc2NvcGVNYXBwaW5nW3Njb3BlXSB8fCB0b0NhbWVsQ2FzZShzY29wZSk7XG4gIH1cblxuICAvKipcbiAgICogSWYgbGFuZyBpcyBzY29wZSB3ZSBuZWVkIHRvIGNoZWNrIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG4gICAqIHRvZG9zL2VzID0+IGluIHRoaXMgY2FzZSB3ZSBzaG91bGQgdGFrZSBgZXNgIGFzIGxhbmdcbiAgICogdG9kb3MgPT4gaW4gdGhpcyBjYXNlIHdlIHNob3VsZCBzZXQgdGhlIGFjdGl2ZSBsYW5nIGFzIGxhbmdcbiAgICovXG4gIHByaXZhdGUgcmVzb2x2ZUxhbmdBbmRTY29wZShsYW5nOiBzdHJpbmcpIHtcbiAgICBsZXQgcmVzb2x2ZUxhbmcgPSBsYW5nO1xuICAgIGxldCBzY29wZTtcblxuICAgIGlmICh0aGlzLl9pc0xhbmdTY29wZWQobGFuZykpIHtcbiAgICAgIC8vIGVuIGZvciBleGFtcGxlXG4gICAgICBjb25zdCBsYW5nRnJvbVNjb3BlID0gZ2V0TGFuZ0Zyb21TY29wZShsYW5nKTtcbiAgICAgIC8vIGVuIGlzIGxhbmdcbiAgICAgIGNvbnN0IGhhc0xhbmcgPSB0aGlzLmlzTGFuZyhsYW5nRnJvbVNjb3BlKTtcbiAgICAgIC8vIHRha2UgZW5cbiAgICAgIHJlc29sdmVMYW5nID0gaGFzTGFuZyA/IGxhbmdGcm9tU2NvcGUgOiB0aGlzLmdldEFjdGl2ZUxhbmcoKTtcbiAgICAgIC8vIGZpbmQgdGhlIHNjb3BlXG4gICAgICBzY29wZSA9IHRoaXMuZ2V0TWFwcGVkU2NvcGUoaGFzTGFuZyA/IGdldFNjb3BlRnJvbUxhbmcobGFuZykgOiBsYW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc2NvcGUsIHJlc29sdmVMYW5nIH07XG4gIH1cblxuICBwcml2YXRlIGdldE9iamVjdEJ5S2V5KHRyYW5zbGF0aW9uOiBUcmFuc2xhdGlvbiwga2V5OiBzdHJpbmcpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBjb25zdCBwcmVmaXggPSBgJHtrZXl9LmA7XG5cbiAgICBmb3IgKGNvbnN0IGN1cnJlbnRLZXkgaW4gdHJhbnNsYXRpb24pIHtcbiAgICAgIGlmIChjdXJyZW50S2V5LnN0YXJ0c1dpdGgocHJlZml4KSkge1xuICAgICAgICByZXN1bHRbY3VycmVudEtleS5yZXBsYWNlKHByZWZpeCwgJycpXSA9IHRyYW5zbGF0aW9uW2N1cnJlbnRLZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBwcml2YXRlIGdldEVudHJpZXMoa2V5OiBIYXNoTWFwIHwgTWFwPHN0cmluZywgSGFzaE1hcD4pIHtcbiAgICByZXR1cm4ga2V5IGluc3RhbmNlb2YgTWFwID8ga2V5LmVudHJpZXMoKSA6IE9iamVjdC5lbnRyaWVzKGtleSk7XG4gIH1cbn1cbiJdfQ==